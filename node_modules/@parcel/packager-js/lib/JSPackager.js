"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _plugin() {
  const data = require("@parcel/plugin");

  _plugin = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _scopeHoisting() {
  const data = require("@parcel/scope-hoisting");

  _scopeHoisting = function () {
    return data;
  };

  return data;
}

function _sourceMap() {
  const data = _interopRequireDefault(require("@parcel/source-map"));

  _sourceMap = function () {
    return data;
  };

  return data;
}

function _traverse() {
  const data = _interopRequireDefault(require("@babel/traverse"));

  _traverse = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PRELUDE = _fs().default.readFileSync(_path().default.join(__dirname, 'prelude.js'), 'utf8').trim().replace(/;$/, '');

var _default = new (_plugin().Packager)({
  async loadConfig({
    options
  }) {
    var _pkg$config$name, _pkg$files;

    // Generate a name for the global parcelRequire function that is unique to this project.
    // This allows multiple parcel builds to coexist on the same page.
    let pkg = await (0, _utils().loadConfig)(options.inputFS, _path().default.join(options.entryRoot, 'index'), ['package.json']);
    let name = (_pkg$config$name = pkg === null || pkg === void 0 ? void 0 : pkg.config.name) !== null && _pkg$config$name !== void 0 ? _pkg$config$name : '';
    return {
      config: {
        parcelRequireName: 'parcelRequire' + (0, _utils().md5FromString)(name).slice(-4)
      },
      files: (_pkg$files = pkg === null || pkg === void 0 ? void 0 : pkg.files) !== null && _pkg$files !== void 0 ? _pkg$files : []
    };
  },

  async package({
    bundle,
    bundleGraph,
    getInlineBundleContents,
    getSourceMapReference,
    config,
    options
  }) {
    function replaceReferences({
      contents,
      map
    }) {
      return (0, _utils().replaceInlineReferences)({
        bundle,
        bundleGraph,
        contents,
        getInlineReplacement: (dependency, inlineType, content) => ({
          from: `"${dependency.id}"`,
          to: inlineType === 'string' ? JSON.stringify(content) : content
        }),
        getInlineBundleContents,
        map
      });
    }

    let parcelRequireName = (0, _nullthrows().default)(config).parcelRequireName; // If scope hoisting is enabled, we use a different code path.

    if (bundle.env.shouldScopeHoist) {
      let wrappedAssets = new Set();
      let ast = (0, _scopeHoisting().link)({
        bundle,
        bundleGraph,
        ast: await (0, _scopeHoisting().concat)({
          bundle,
          bundleGraph,
          options,
          wrappedAssets
        }),
        options,
        wrappedAssets,
        parcelRequireName
      }); // Free up memory

      _traverse().default.cache.clear();

      let {
        contents,
        map
      } = (0, _scopeHoisting().generate)({
        bundle,
        ast,
        options
      });
      return replaceReferences({
        contents: contents + '\n' + (await getSourceMapSuffix(getSourceMapReference, map)),
        map
      });
    }

    if (bundle.env.outputFormat === 'esmodule') {
      throw new Error(`esmodule output is not supported without scope hoisting.`);
    } // For development, we just concatenate all of the code together
    // rather then enabling scope hoisting, which would be too slow.


    let queue = new (_utils().PromiseQueue)({
      maxConcurrent: 32
    });
    bundle.traverse(node => {
      if (node.type === 'asset') {
        queue.add(async () => {
          let [code, mapBuffer] = await Promise.all([node.value.getCode(), bundle.env.sourceMap && node.value.getMapBuffer()]);
          return {
            code,
            mapBuffer
          };
        });
      }
    });
    let results = await queue.run();
    let assets = '';
    let i = 0;
    let first = true;
    let map = new (_sourceMap().default)(options.projectRoot);
    let prefix = getPrefix(bundle, bundleGraph);
    let lineOffset = (0, _utils().countLines)(prefix);
    bundle.traverse(node => {
      let wrapped = first ? '' : ',';

      if (node.type === 'dependency') {
        let resolved = bundleGraph.getDependencyResolution(node.value, bundle);

        if (resolved && resolved.type !== 'js') {
          // if this is a reference to another javascript asset, we should not include
          // its output, as its contents should already be loaded.
          (0, _assert().default)(!bundle.hasAsset(resolved));
          wrapped += JSON.stringify(bundleGraph.getAssetPublicId(resolved)) + ':[function() {},{}]';
        } else {
          return;
        }
      }

      if (node.type === 'asset') {
        let asset = node.value;
        (0, _assert().default)(asset.type === 'js', 'all assets in a js bundle must be js assets');
        let deps = {};
        let dependencies = bundleGraph.getDependencies(asset);

        for (let dep of dependencies) {
          let resolved = bundleGraph.getDependencyResolution(dep, bundle);

          if (resolved) {
            deps[dep.moduleSpecifier] = bundleGraph.getAssetPublicId(resolved);
          }
        }

        let {
          code,
          mapBuffer
        } = results[i];
        let output = code || '';
        wrapped += JSON.stringify(bundleGraph.getAssetPublicId(asset)) + ':[function(require,module,exports) {\n' + output + '\n},';
        wrapped += JSON.stringify(deps);
        wrapped += ']';

        if (bundle.env.sourceMap) {
          if (mapBuffer) {
            map.addBufferMappings(mapBuffer, lineOffset);
          } else {
            map.addEmptyMap(_path().default.relative(options.projectRoot, asset.filePath).replace(/\\+/g, '/'), output, lineOffset);
          }

          lineOffset += (0, _utils().countLines)(output) + 1;
        }

        i++;
      }

      assets += wrapped;
      first = false;
    });
    let entries = bundle.getEntryAssets();
    let mainEntry = bundle.getMainEntry();

    if (!isEntry(bundle, bundleGraph) && bundle.env.outputFormat === 'global') {
      // In async bundles we don't want the main entry to execute until we require it
      // as there might be dependencies in a sibling bundle that hasn't loaded yet.
      entries = entries.filter(a => {
        var _mainEntry;

        return a.id !== ((_mainEntry = mainEntry) === null || _mainEntry === void 0 ? void 0 : _mainEntry.id);
      });
      mainEntry = null;
    }

    return replaceReferences({
      contents: prefix + '({' + assets + '},' + JSON.stringify(entries.map(asset => bundleGraph.getAssetPublicId(asset))) + ', ' + JSON.stringify(mainEntry ? bundleGraph.getAssetPublicId(mainEntry) : null) + ', ' + JSON.stringify(parcelRequireName) + ')' + '\n\n' + (await getSourceMapSuffix(getSourceMapReference, map)),
      map
    });
  }

});

exports.default = _default;

function getPrefix(bundle, bundleGraph) {
  let interpreter;
  let mainEntry = bundle.getMainEntry();

  if (mainEntry && isEntry(bundle, bundleGraph) && !bundle.target.env.isBrowser()) {
    let _interpreter = mainEntry.meta.interpreter;
    (0, _assert().default)(_interpreter == null || typeof _interpreter === 'string');
    interpreter = _interpreter;
  }

  let importScripts = '';

  if (bundle.env.isWorker()) {
    let bundles = bundleGraph.getReferencedBundles(bundle);

    for (let b of bundles) {
      importScripts += `importScripts("${(0, _utils().relativeBundlePath)(bundle, b)}");\n`;
    }
  }

  return (// If the entry asset included a hashbang, repeat it at the top of the bundle
    (interpreter != null ? `#!${interpreter}\n` : '') + importScripts + PRELUDE
  );
}

function isEntry(bundle, bundleGraph) {
  var _bundle$getMainEntry;

  return !bundleGraph.hasParentBundleOfType(bundle, 'js') || bundle.env.isIsolated() || !!((_bundle$getMainEntry = bundle.getMainEntry()) !== null && _bundle$getMainEntry !== void 0 && _bundle$getMainEntry.isIsolated);
}

async function getSourceMapSuffix(getSourceMapReference, map) {
  let sourcemapReference = await getSourceMapReference(map);

  if (sourcemapReference != null) {
    return '//# sourceMappingURL=' + sourcemapReference + '\n';
  } else {
    return '';
  }
}