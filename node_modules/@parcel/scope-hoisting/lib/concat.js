"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concat = concat;

function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function () {
    return data;
  };

  return data;
}

function _babylonWalk() {
  const data = require("@parcel/babylon-walk");

  _babylonWalk = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _template() {
  const data = _interopRequireDefault(require("@babel/template"));

  _template = function () {
    return data;
  };

  return data;
}

function _utils2() {
  const data = require("./utils");

  _utils2 = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const DEFAULT_INTEROP_TEMPLATE = _template().default.statement('var NAME = /*@__PURE__*/$parcel$interopDefault(MODULE);', {
  preserveComments: true
});

const ESMODULE_TEMPLATE = _template().default.statement(`$parcel$defineInteropFlag(EXPORTS);`);

// eslint-disable-next-line no-unused-vars
async function concat({
  bundle,
  bundleGraph,
  options,
  wrappedAssets
}) {
  let queue = new (_utils().PromiseQueue)({
    maxConcurrent: 32
  });
  bundle.traverse((node, shouldWrap) => {
    switch (node.type) {
      case 'dependency':
        // Mark assets that should be wrapped, based on metadata in the incoming dependency tree
        if (shouldWrap || node.value.meta.shouldWrap) {
          let resolved = bundleGraph.getDependencyResolution(node.value, bundle);

          if (resolved && resolved.sideEffects) {
            wrappedAssets.add(resolved.id);
          }

          return true;
        }

        break;

      case 'asset':
        queue.add(() => processAsset(options, bundleGraph, bundle, node.value, wrappedAssets));
    }
  });
  let outputs = new Map(await queue.run());
  let result = []; // Note: for each asset, the order of `$parcel$require` calls and the corresponding
  // `asset.getDependencies()` must be the same!

  bundle.traverseAssets({
    enter(asset, context) {
      // Do not skip over excluded assets entirely, since their dependencies need
      // to be in the correct order and they themselves need to be inserted correctly
      // into the parent again.
      return {
        parent: context && context.children,
        children: new Map()
      };
    },

    exit(asset, context) {
      if (!context) {
        return;
      }

      let statements = (0, _nullthrows().default)(outputs.get(asset.id));
      let statementIndices = new Map();

      for (let i = 0; i < statements.length; i++) {
        let statement = statements[i];

        if ((0, t().isVariableDeclaration)(statement) || (0, t().isExpressionStatement)(statement)) {
          for (let depAsset of findRequires(bundle, bundleGraph, asset, statement)) {
            if (!statementIndices.has(depAsset.id)) {
              statementIndices.set(depAsset.id, i);
            }
          }
        }
      }

      if (shouldSkipAsset(bundleGraph, bundle, asset)) {
        // The order of imports of excluded assets has to be retained
        statements = [...context.children].sort(([aId], [bId]) => (0, _nullthrows().default)(statementIndices.get(aId)) - (0, _nullthrows().default)(statementIndices.get(bId))).map(([, ast]) => ast).flat();
      } else {
        // splice assets with missing statementIndices last (= put wrapped asset at the top)
        let wrapped = [];

        for (let [assetId, ast] of [...context.children].reverse()) {
          let index = statementIndices.get(assetId);

          if (index) {
            statements.splice(index, 0, ...ast);
          } else {
            wrapped.push(ast);
          }
        }

        for (let ast of wrapped) {
          statements.unshift(...ast);
        }
      } // If this module is referenced by another JS bundle, or is an entry module in a child bundle,
      // add code to register the module with the module system.


      if (context.parent) {
        context.parent.set(asset.id, statements);
      } else {
        result.push(...statements);
      }
    }

  });
  return t().file(t().program(result));
}

async function processAsset(options, bundleGraph, bundle, asset, wrappedAssets) {
  let statements;

  if (asset.astGenerator && asset.astGenerator.type === 'babel') {
    let ast = await asset.getAST();
    statements = t().cloneNode((0, _nullthrows().default)(ast).program.program).body;
  } else {
    let code = await asset.getCode();
    statements = (0, _utils2().parse)(code, (0, _utils().relativeUrl)(options.projectRoot, asset.filePath));
  } // If this is a CommonJS module, add an interop default declaration if there are any ES6 default
  // import dependencies in the same bundle for that module.


  if ((0, _utils2().needsDefaultInterop)(bundleGraph, bundle, asset)) {
    statements.push(DEFAULT_INTEROP_TEMPLATE({
      NAME: (0, _utils2().getIdentifier)(asset, '$interop$default'),
      MODULE: t().identifier((0, _utils2().assertString)(asset.meta.exportsIdentifier))
    }));
  } // If this is an ES6 module with a default export, and it's required by a
  // CommonJS module in the same bundle, then add an __esModule flag for interop with babel.


  if (asset.meta.isES6Module && asset.symbols.hasExportSymbol('default')) {
    let deps = bundleGraph.getIncomingDependencies(asset);
    let hasCJSDep = deps.some(dep => dep.meta.isCommonJS && !dep.isAsync && dep.symbols.hasExportSymbol('*'));

    if (hasCJSDep) {
      statements.push(ESMODULE_TEMPLATE({
        EXPORTS: t().identifier((0, _utils2().assertString)(asset.meta.exportsIdentifier))
      }));
    }
  }

  if (wrappedAssets.has(asset.id)) {
    statements = wrapModule(asset, statements);
  }

  if (statements[0]) {
    t().addComment(statements[0], 'leading', ` ASSET: ${(0, _utils().relativePath)(options.projectRoot, asset.filePath, false)}`, true);
  }

  return [asset.id, statements];
}

function shouldSkipAsset(bundleGraph, bundle, asset) {
  return asset.sideEffects === false && bundleGraph.getUsedSymbols(asset).size == 0 && !bundleGraph.isAssetReferencedByDependant(bundle, asset);
}

const FIND_REQUIRES_VISITOR = {
  CallExpression(node, {
    bundle,
    bundleGraph,
    asset,
    result
  }) {
    let {
      arguments: args,
      callee
    } = node;

    if (!(0, t().isIdentifier)(callee)) {
      return;
    }

    if (callee.name === '$parcel$require') {
      let [, src] = args;
      (0, _assert().default)((0, t().isStringLiteral)(src));
      let dep = bundleGraph.getDependencies(asset).find(dep => dep.moduleSpecifier === src.value);

      if (!dep) {
        throw new Error(`Could not find dep for "${src.value}`);
      } // can be undefined if AssetGraph#resolveDependency optimized
      // ("deferred") this dependency away as an unused reexport


      let resolution = bundleGraph.getDependencyResolution(dep, bundle);

      if (resolution) {
        result.push(resolution);
      }
    }
  }

};

function findRequires(bundle, bundleGraph, asset, ast) {
  let result = [];
  (0, _babylonWalk().simple)(ast, FIND_REQUIRES_VISITOR, {
    asset,
    bundle,
    bundleGraph,
    result
  });
  return result;
} // Toplevel var/let/const declarations, function declarations and all `var` declarations
// in a non-function scope need to be hoisted.


const WRAP_MODULE_VISITOR = {
  VariableDeclaration(node, {
    decls
  }, ancestors) {
    let parent = ancestors[ancestors.length - 2];
    let isParentForX = (0, t().isForInStatement)(parent, {
      left: node
    }) || (0, t().isForOfStatement)(parent, {
      left: node
    });
    let isParentFor = (0, t().isForStatement)(parent, {
      init: node
    });

    if (node.kind === 'var' || (0, t().isProgram)(parent)) {
      let replace = [];

      for (let decl of node.declarations) {
        let {
          id,
          init
        } = decl;

        if ((0, t().isObjectPattern)(id) || (0, t().isArrayPattern)(id)) {
          // $FlowFixMe it is an identifier
          let ids = Object.values(t().getBindingIdentifiers(id));

          for (let prop of ids) {
            decls.push(t().variableDeclarator(prop));
          }
        } else {
          decls.push(t().variableDeclarator(id));
          (0, _assert().default)(t().isIdentifier(id));
        }

        if (isParentForX) {
          replace.push(id);
        } else if (init) {
          replace.push(t().assignmentExpression('=', id, init));
        }
      }

      if (replace.length > 0) {
        let n = replace.length > 1 ? t().sequenceExpression(replace) : replace[0];

        if (!(isParentFor || isParentForX)) {
          n = t().expressionStatement(n);
        }

        return n;
      } else {
        return _babylonWalk().REMOVE;
      }
    }

    return _babylonWalk().SKIP;
  },

  FunctionDeclaration(node, {
    fns
  }) {
    fns.push(node);
    return _babylonWalk().REMOVE;
  },

  ClassDeclaration(node, {
    decls
  }) {
    let {
      id
    } = node;
    (0, _assert().default)((0, t().isIdentifier)(id)); // Class declarations are not hoisted (they behave like `let`). We declare a variable
    // outside the function and convert to a class expression assignment.

    decls.push(t().variableDeclarator(id));
    return t().expressionStatement(t().assignmentExpression('=', id, t().toExpression(node)));
  },

  'Function|Class'() {
    return _babylonWalk().SKIP;
  },

  shouldSkip(node) {
    return t().isExpression(node);
  }

};

function wrapModule(asset, statements) {
  let decls = [];
  let fns = [];
  let program = t().program(statements);
  (0, _babylonWalk().traverse2)(program, WRAP_MODULE_VISITOR, {
    asset,
    decls,
    fns
  });
  let executed = (0, _utils2().getName)(asset, 'executed');
  decls.push(t().variableDeclarator(t().identifier(executed), t().booleanLiteral(false)));
  let execId = (0, _utils2().getIdentifier)(asset, 'exec');
  let exec = t().functionDeclaration(execId, [], t().blockStatement(program.body));
  let init = t().functionDeclaration((0, _utils2().getIdentifier)(asset, 'init'), [], t().blockStatement([t().ifStatement(t().unaryExpression('!', t().identifier(executed)), t().blockStatement([t().expressionStatement(t().assignmentExpression('=', t().identifier(executed), t().booleanLiteral(true))), t().expressionStatement(t().callExpression(execId, []))])), t().returnStatement(t().identifier((0, _utils2().assertString)(asset.meta.exportsIdentifier)))]));
  return [t().variableDeclaration('var', decls), ...fns, exec, init];
}