"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getName = getName;
exports.getIdentifier = getIdentifier;
exports.getExportIdentifier = getExportIdentifier;
exports.needsPrelude = needsPrelude;
exports.isEntry = isEntry;
exports.isReferenced = isReferenced;
exports.hasAsyncDescendant = hasAsyncDescendant;
exports.needsDefaultInterop = needsDefaultInterop;
exports.assertString = assertString;
exports.pathDereference = pathDereference;
exports.pathRemove = pathRemove;
exports.dereferenceIdentifier = dereferenceIdentifier;
exports.removeReplaceBinding = removeReplaceBinding;
exports.verifyScopeState = verifyScopeState;
exports.getThrowableDiagnosticForNode = getThrowableDiagnosticForNode;
exports.parse = parse;
exports.getHelpers = getHelpers;

function _parser() {
  const data = require("@babel/parser");

  _parser = function () {
    return data;
  };

  return data;
}

function _babylonWalk() {
  const data = require("@parcel/babylon-walk");

  _babylonWalk = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = _interopRequireDefault(require("@parcel/diagnostic"));

  _diagnostic = function () {
    return data;
  };

  return data;
}

function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getName(asset, type, ...rest) {
  return t().toIdentifier('$' + asset.id + '$' + type + (rest.length ? '$' + rest.join('$') : ''));
}

function getIdentifier(asset, type, ...rest) {
  return t().identifier(getName(asset, type, ...rest));
}

function getExportIdentifier(asset, name) {
  return getIdentifier(asset, 'export', name);
}

function needsPrelude(bundle, bundleGraph) {
  var _bundle$getMainEntry;

  if (bundle.env.outputFormat !== 'global') {
    return false;
  }

  let parentBundles = bundleGraph.getParentBundles(bundle);
  let mightBeFirstJS = parentBundles.length === 0 || parentBundles.some(b => b.type !== 'js') || bundleGraph.getBundleGroupsContainingBundle(bundle).some(g => bundleGraph.isEntryBundleGroup(g)) || bundle.env.isIsolated() || !!((_bundle$getMainEntry = bundle.getMainEntry()) !== null && _bundle$getMainEntry !== void 0 && _bundle$getMainEntry.isIsolated); // If this might be loaded as the first script in the context and it is referenced by other bundles,
  // we need to add the prelude code, which allows registering modules dynamically at runtime.

  return mightBeFirstJS && ( // If this bundle has an async descendant, it will use the JSRuntime,
  // which uses parcelRequire. It's also possible that the descendant needs
  // to register exports for its own descendants.
  hasAsyncDescendant(bundle, bundleGraph) || // If an asset in this bundle is referenced, this bundle will use
  //`parcelRequire.register` to register the asset.
  isReferenced(bundle, bundleGraph));
}

function isEntry(bundle, bundleGraph) {
  var _bundle$getMainEntry2;

  // If there is no parent JS bundle (e.g. in an HTML page), or environment is isolated (e.g. worker)
  // then this bundle is an "entry"
  return !bundleGraph.hasParentBundleOfType(bundle, 'js') || bundle.env.isIsolated() || !!((_bundle$getMainEntry2 = bundle.getMainEntry()) !== null && _bundle$getMainEntry2 !== void 0 && _bundle$getMainEntry2.isIsolated);
}

function isReferenced(bundle, bundleGraph) {
  let isReferenced = false;
  bundle.traverseAssets((asset, _, actions) => {
    // A bundle is potentially referenced if any of its assets is referenced
    // by any of its siblings, descendants, siblings of descendants, or
    // descendants of siblings.
    if (bundleGraph.isAssetReferencedByDependant(bundle, asset)) {
      isReferenced = true;
      actions.stop();
    }
  });
  return isReferenced;
}

function hasAsyncDescendant(bundle, bundleGraph) {
  let _hasAsyncDescendant = false;
  bundleGraph.traverseBundles((b, _, actions) => {
    if (b.id === bundle.id) {
      return;
    }

    if (b.env.context !== bundle.env.context || b.type !== 'js') {
      actions.skipChildren();
      return;
    }

    if (b.getMainEntry()) {
      _hasAsyncDescendant = true;
      actions.stop();
    }
  }, bundle);
  return _hasAsyncDescendant;
}

function needsDefaultInterop(bundleGraph, bundle, asset) {
  let deps = bundleGraph.getIncomingDependencies(asset);

  if (asset.meta.isCommonJS && !asset.symbols.hasExportSymbol('default')) {
    return deps.some(dep => bundle.hasDependency(dep) && dep.meta.isES6Module && dep.symbols.hasExportSymbol('default'));
  }

  return false;
}

function assertString(v) {
  (0, _assert().default)(typeof v === 'string');
  return v;
}

const DereferenceVisitor = {
  Identifier(node, scope) {
    dereferenceIdentifier(node, scope);
  }

}; // updates bindings in path.scope.getProgramParent()

function pathDereference(path) {
  (0, _babylonWalk().simple)(path.node, DereferenceVisitor, path.scope.getProgramParent());
} // like path.remove(), but updates bindings in path.scope.getProgramParent()


function pathRemove(path) {
  pathDereference(path);
  path.remove();
}

function dereferenceIdentifier(node, scope) {
  let binding = scope.getBinding(node.name);

  if (binding) {
    let i = binding.referencePaths.findIndex(v => v.node === node);

    if (i >= 0) {
      binding.dereference();
      binding.referencePaths.splice(i, 1);
    }

    let j = binding.constantViolations.findIndex(v => Object.values(v.getBindingIdentifiers()).includes(node));

    if (j >= 0) {
      binding.constantViolations.splice(j, 1);

      if (binding.constantViolations.length == 0) {
        binding.constant = true;
      }
    }
  }
}

function removeReplaceBinding(scope, name, newPath, newKind) {
  let binding = (0, _nullthrows().default)(scope.getBinding(name));
  let path = binding.path;
  let {
    node,
    parent
  } = path;
  (0, _assert().default)((0, t().isVariableDeclarator)(node) && (0, t().isVariableDeclaration)(parent) && !node.init); // `path.remove()`ing a declaration also removes the corresponding binding. But we want to keep
  // the binding and only replace the declaration. path._remove() merely removes the node in the AST.
  // $FlowFixMe

  path._remove();

  if (parent.declarations.length === 0) {
    path.parentPath.remove();
  }

  binding.path = newPath;
  binding.identifier = newPath.getBindingIdentifiers()[name];

  if (newKind) {
    binding.kind = newKind;
  }
}

function verifyScopeState(scope) {
  let oldBindings = scope.bindings;
  scope.crawl();
  let newBindings = scope.bindings;
  (0, _assert().default)(Object.keys(oldBindings).length === Object.keys(newBindings).length);

  for (let name of Object.keys(newBindings)) {
    (0, _assert().default)(newBindings[name], name);
    let {
      scope: aScope,
      constantViolations: aConstantViolations,
      referencePaths: aReferencePaths,
      identifier: aId,
      path: aPath,
      ...a
    } = oldBindings[name];
    let {
      scope: bScope,
      constantViolations: bConstantViolations,
      referencePaths: bReferencePaths,
      identifier: bId,
      path: bPath,
      ...b
    } = newBindings[name];
    (0, _assert().default)(aPath === bPath, name);
    (0, _assert().default)(aId === bId, name);
    (0, _assert().default)(aScope === bScope, name);

    _assert().default.deepStrictEqual(a, b, name);

    (0, _assert().default)(aConstantViolations.length === bConstantViolations.length, name);

    for (let p of bConstantViolations) {
      (0, _assert().default)(aConstantViolations.indexOf(p) >= 0, name);
    }

    (0, _assert().default)(aReferencePaths.length === bReferencePaths.length, name);

    for (let p of bReferencePaths) {
      (0, _assert().default)(aReferencePaths.indexOf(p) >= 0, name);
    }
  }
}

function getThrowableDiagnosticForNode(message, filePath, loc) {
  let diagnostic = {
    message,
    language: 'js'
  };

  if (filePath) {
    diagnostic.filePath = _path().default.normalize(filePath);
  }

  if (loc) {
    diagnostic.codeFrame = {
      codeHighlights: [{
        start: loc.start,
        end: loc.end
      }]
    };
  }

  return new (_diagnostic().default)({
    diagnostic
  });
}

function parse(code, sourceFilename) {
  let ast = (0, _parser().parse)(code, {
    sourceFilename,
    allowReturnOutsideFunction: true,
    plugins: ['dynamicImport']
  });
  return ast.program.body;
}

let helpersCache;

function getHelpers() {
  if (helpersCache != null) {
    return helpersCache;
  }

  let helpersPath = _path().default.join(__dirname, 'helpers.js');

  let statements = parse(_fs().default.readFileSync(helpersPath, 'utf8'), helpersPath);
  helpersCache = new Map();

  for (let statement of statements) {
    if ((0, t().isVariableDeclaration)(statement)) {
      if (statement.declarations.length !== 1 || !(0, t().isIdentifier)(statement.declarations[0].id)) {
        throw new Error('Unsupported helper');
      }

      helpersCache.set(statement.declarations[0].id.name, statement);
    } else if ((0, t().isFunctionDeclaration)(statement) && (0, t().isIdentifier)(statement.id)) {
      helpersCache.set(statement.id.name, statement);
    } else {
      throw new Error('Unsupported helper');
    }
  }

  return helpersCache;
}