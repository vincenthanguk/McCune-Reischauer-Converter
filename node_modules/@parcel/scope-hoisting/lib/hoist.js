"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hoist = hoist;

function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function () {
    return data;
  };

  return data;
}

function _traverse() {
  const data = _interopRequireDefault(require("@babel/traverse"));

  _traverse = function () {
    return data;
  };

  return data;
}

function _template() {
  const data = _interopRequireDefault(require("@babel/template"));

  _template = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _babelAstUtils() {
  const data = require("@parcel/babel-ast-utils");

  _babelAstUtils = function () {
    return data;
  };

  return data;
}

function _renamer() {
  const data = _interopRequireDefault(require("./renamer"));

  _renamer = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("./utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const WRAPPER_TEMPLATE = _template().default.statement(`
  var NAME = (function () {
    var exports = this;
    var module = {exports: this};
    BODY;
    return module.exports;
  }).call({});
`);

const ESMODULE_TEMPLATE = _template().default.statement(`exports.__esModule = true;`);

const EXPORT_TEMPLATE = _template().default.statement('$parcel$export(EXPORTS, NAME, function(){return LOCAL;});');

const EXPORT_ALL_TEMPLATE = _template().default.statement('$parcel$exportWildcard(OLD_NAME, $parcel$require(ID, SOURCE));');

const REQUIRE_CALL_TEMPLATE = _template().default.expression('$parcel$require(ID, SOURCE)');

const REQUIRE_RESOLVE_CALL_TEMPLATE = _template().default.expression('$parcel$require$resolve(ID, SOURCE)');

const TYPEOF = {
  module: 'object',
  require: 'function'
};

function hoist(asset, ast) {
  if (ast.type !== 'babel' || ast.version !== '7.0.0') {
    throw new Error('Asset does not have a babel AST');
  }

  (0, _traverse().default)(ast.program, VISITOR, null, asset);
  asset.setAST(ast);
}

const VISITOR = {
  Program: {
    enter(path, asset) {
      asset.symbols.ensure();
      asset.meta.id = asset.id;
      asset.meta.exportsIdentifier = (0, _utils().getName)(asset, 'exports');
      asset.meta.staticExports = true;

      _traverse().default.cache.clearScope();

      path.scope.crawl();
      let shouldWrap = false;
      path.traverse({
        ImportDeclaration() {
          asset.meta.isES6Module = true;
        },

        ExportDeclaration() {
          asset.meta.isES6Module = true;
        },

        CallExpression(path) {
          // If we see an `eval` call, wrap the module in a function.
          // Otherwise, local variables accessed inside the eval won't work.
          let callee = path.node.callee;

          if ((0, t().isIdentifier)(callee) && callee.name === 'eval' && !path.scope.hasBinding('eval', true)) {
            asset.meta.isCommonJS = true;
            shouldWrap = true;
            path.stop();
          }
        },

        ReturnStatement(path) {
          // Wrap in a function if we see a top-level return statement.
          if (!path.getFunctionParent()) {
            shouldWrap = true;
            asset.meta.isCommonJS = true;
            path.replaceWith(t().returnStatement(t().memberExpression(t().identifier('module'), t().identifier('exports'))));
            path.stop();
          }
        },

        ReferencedIdentifier(path) {
          let {
            parent,
            node
          } = path; // We must wrap if `module` is referenced as a free identifier rather
          // than a statically resolvable member expression.

          if (node.name === 'module' && !isStaticMemberExpression(parent) && !((0, t().isUnaryExpression)(parent) && parent.operator === 'typeof') && !path.scope.hasBinding('module') && !path.scope.getData('shouldWrap')) {
            asset.meta.isCommonJS = true;
            shouldWrap = true;
            path.stop();
          } // We must disable resolving $..$exports.foo if `exports`
          // is referenced as a free identifier rather
          // than a statically resolvable member expression.


          if (node.name === 'exports' && !path.scope.hasBinding('exports')) {
            asset.meta.isCommonJS = true;

            if (!((0, t().isAssignmentExpression)(parent, {
              left: node
            }) || isStaticMemberExpression(parent) || path.scope.getData('shouldWrap'))) {
              asset.meta.staticExports = false; // The namespace object is used in the asset itself

              asset.addDependency({
                moduleSpecifier: `./${(0, _path().basename)(asset.filePath)}`,
                symbols: new Map([['*', {
                  local: '@exports',
                  isWeak: false,
                  loc: (0, _babelAstUtils().convertBabelLoc)(path.node.loc)
                }]])
              });
            }
          }
        },

        MemberExpression(path) {
          let {
            node,
            parent
          } = path; // We must disable resolving $..$exports.foo if `exports`
          // is referenced as a free identifier rather
          // than a statically resolvable member expression.

          if (t().matchesPattern(node, 'module.exports') && !path.scope.hasBinding('module')) {
            asset.meta.isCommonJS = true;

            if (!((0, t().isAssignmentExpression)(parent, {
              left: node
            }) || isStaticMemberExpression(parent) || path.scope.getData('shouldWrap'))) {
              asset.meta.staticExports = false; // The namespace object is used in the asset itself

              asset.addDependency({
                moduleSpecifier: `./${(0, _path().basename)(asset.filePath)}`,
                symbols: new Map([['*', {
                  local: '@exports',
                  isWeak: false,
                  loc: (0, _babelAstUtils().convertBabelLoc)(path.node.loc)
                }]])
              });
            }
          }
        }

      });

      if (!asset.meta.isCommonJS && !asset.meta.isES6Module) {
        // Assume CommonJS (still needs exports object)
        asset.meta.isCommonJS = true;
        asset.symbols.set('*', (0, _utils().getName)(asset, 'exports'));
      }

      path.scope.setData('shouldWrap', shouldWrap);
      path.scope.setData('cjsExportsReassigned', false);

      if (shouldWrap) {
        asset.meta.staticExports = false;
      }
    },

    exit(path, asset) {
      let scope = path.scope;
      let exportsIdentifier = (0, _utils().getIdentifier)(asset, 'exports');

      if (scope.getData('shouldWrap')) {
        if (asset.meta.isES6Module) {
          path.unshiftContainer('body', [ESMODULE_TEMPLATE()]);
        }

        path.replaceWith(t().program([WRAPPER_TEMPLATE({
          NAME: exportsIdentifier,
          BODY: path.node.body
        })]));
        asset.symbols.set('*', exportsIdentifier.name);
        asset.meta.isCommonJS = true;
        asset.meta.isES6Module = false;
      } else {
        // Re-crawl scope so we are sure to have all bindings.
        _traverse().default.cache.clearScope();

        scope.crawl(); // Rename each binding in the top-level scope to something unique.

        for (let name in scope.bindings) {
          if (!name.startsWith(t().toIdentifier('$' + asset.id))) {
            let newName = (0, _utils().getName)(asset, 'var', name);
            (0, _renamer().default)(scope, name, newName);
          }
        } // Add variable that represents module.exports if it is referenced and not declared.


        if (!scope.hasBinding(exportsIdentifier.name)) {
          scope.push({
            id: exportsIdentifier,
            init: t().objectExpression([])
          });
        }

        if (asset.meta.isCommonJS) {
          asset.symbols.set('*', exportsIdentifier.name);
        }
      }

      path.stop();
    }

  },

  DirectiveLiteral(path) {
    // Remove 'use strict' directives, since modules are concatenated - one strict mode
    // module should not apply to all other modules in the same scope.
    if (path.node.value === 'use strict') {
      path.parentPath.remove();
    }
  },

  MemberExpression(path, asset) {
    if (path.scope.hasBinding('module') || path.scope.getData('shouldWrap')) {
      return;
    }

    if (t().matchesPattern(path.node, 'module.exports')) {
      // Replace module.exports.foo with exported identifier if possible,
      // and add a self-referencing dependency so we know the symbol is used.
      let selfReference = addSelfReference(path, asset);

      if (selfReference) {
        path.parentPath.replaceWith(selfReference);
      } else {
        let exportsId = getExportsIdentifier(asset, path.scope);
        asset.symbols.set('*', exportsId.name, (0, _babelAstUtils().convertBabelLoc)(path.node.loc));
        path.replaceWith(exportsId);

        if (!path.scope.hasBinding(exportsId.name)) {
          path.scope.getProgramParent().push({
            id: t().clone(exportsId),
            init: t().objectExpression([])
          });
        }
      }
    } else if (t().matchesPattern(path.node, 'module.id')) {
      path.replaceWith(t().stringLiteral(asset.id));
    } else if (t().matchesPattern(path.node, 'module.hot')) {
      path.replaceWith(t().identifier('null'));
    } else if (t().matchesPattern(path.node, 'module.require') && !asset.env.isNode()) {
      path.replaceWith(t().identifier('null'));
    } else if (t().matchesPattern(path.node, 'module.bundle.root') || t().matchesPattern(path.node, 'module.bundle')) {
      path.replaceWith(t().identifier('parcelRequire'));
    }
  },

  ReferencedIdentifier(path, asset) {
    if (path.node.name === 'exports' && !path.scope.hasBinding('exports') && !path.scope.getData('shouldWrap')) {
      asset.meta.isCommonJS = true; // Mark if exports is accessed non-statically.

      if (!isStaticMemberExpression(path.parent)) {
        asset.meta.staticExports = false;
      } // Replace exports.foo with exported identifier if possible,
      // and add a self-referencing dependency so we know the symbol is used.


      let selfReference = addSelfReference(path, asset);

      if (selfReference) {
        path.parentPath.replaceWith(selfReference);
      } else {
        path.replaceWith(getCJSExportsIdentifier(asset, path.scope));
      }
    }

    if (path.node.name === 'global' && !path.scope.hasBinding('global')) {
      path.replaceWith(t().identifier('$parcel$global'));
    }
  },

  ThisExpression(path, asset) {
    if (!path.scope.getData('shouldWrap')) {
      let scope = path.scope;

      while ((_scope = scope) !== null && _scope !== void 0 && _scope.parent) {
        var _scope;

        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression() || scope.path.isClassDeclaration()) {
          return;
        }

        scope = scope.parent;
      }

      asset.meta.isCommonJS = true; // Mark if exports is accessed non-statically.

      if (!isStaticMemberExpression(path.parent)) {
        asset.meta.staticExports = false;
      }

      if (asset.meta.isES6Module) {
        path.replaceWith(t().identifier('undefined'));
      } else {
        // Replace this.foo with exported identifier if possible,
        // and add a self-referencing dependency so we know the symbol is used.
        let selfReference = addSelfReference(path, asset);

        if (selfReference) {
          path.parentPath.replaceWith(selfReference);
        } else {
          path.replaceWith(getExportsIdentifier(asset, path.scope));
        }
      }
    }
  },

  AssignmentExpression(path, asset) {
    if (path.scope.getData('shouldWrap')) {
      return;
    }

    let {
      left,
      right
    } = path.node; // Match module.exports = expression; assignments and replace with a variable declaration
    // if this is the first assignemnt. This avoids the extra empty object assignment in many cases.
    //
    // TODO: Re-introduce this when it can handle both exports and module.exports concurrently
    //
    // if (
    //   t.matchesPattern(left, 'module.exports') &&
    //   !path.scope.hasBinding('module')
    // ) {
    //   let exportsId = getExportsIdentifier(asset, path.scope);
    //   asset.meta.isCommonJS = true;
    //   asset.symbols.set('*', exportsId.name);
    //   if (
    //     path.scope === path.scope.getProgramParent() &&
    //     !path.scope.getBinding(exportsId.name) &&
    //     path.parentPath.isStatement()
    //   ) {
    //     let [decl] = path.parentPath.replaceWith(
    //       t.variableDeclaration('var', [
    //         t.variableDeclarator(exportsId, right),
    //       ]),
    //     );
    //     path.scope.registerDeclaration(decl);
    //   }
    // }

    if ((0, t().isIdentifier)(left) && left.name === 'exports' && !path.scope.hasBinding('exports')) {
      path.scope.getProgramParent().setData('cjsExportsReassigned', true);
      path.get('left').replaceWith(getCJSExportsIdentifier(asset, path.scope));
      asset.meta.isCommonJS = true;
      asset.meta.staticExports = false;
    } // If we can statically evaluate the name of a CommonJS export, create an ES6-style export for it.
    // This allows us to remove the CommonJS export object completely in many cases.


    if ((0, t().isMemberExpression)(left) && ((0, t().isIdentifier)(left.object, {
      name: 'exports'
    }) && !path.scope.hasBinding('exports') || t().matchesPattern(left.object, 'module.exports') && !path.scope.hasBinding('module')) && ((0, t().isIdentifier)(left.property) && !left.computed || (0, t().isStringLiteral)(left.property))) {
      let name = (0, t().isIdentifier)(left.property) ? left.property.name : left.property.value;
      let identifier = (0, _utils().getExportIdentifier)(asset, name); // Replace the CommonJS assignment with a reference to the ES6 identifier.

      path.get('left.object').replaceWith(getExportsIdentifier(asset, path.scope));
      path.get('right').replaceWith(identifier); // If this is the first assignment, create a binding for the ES6-style export identifier.
      // Otherwise, assign to the existing export binding.

      let scope = path.scope.getProgramParent();

      if (!scope.hasBinding(identifier.name)) {
        // If in the program scope, create a variable declaration and initialize with the exported value.
        // Otherwise, declare the variable in the program scope, and assign to it here.
        if (path.scope === scope) {
          let [decl] = path.insertBefore(t().variableDeclaration('var', [t().variableDeclarator(t().clone(identifier), right)]));
          scope.registerDeclaration(decl);
        } else {
          scope.push({
            id: t().clone(identifier)
          });
          path.insertBefore(t().expressionStatement(t().assignmentExpression('=', t().clone(identifier), right)));
        } // These have a special meaning, we'll have to fallback from the '*' symbol.
        // '*' will always be registered into the symbols at the end.


        if ((name !== 'default' || asset.symbols.hasExportSymbol('__esModule')) && name !== '*') {
          asset.symbols.set(name, identifier.name, (0, _babelAstUtils().convertBabelLoc)(path.node.loc), {
            isPure: isPure(scope.getBinding(identifier.name))
          });
        }
      } else {
        var _asset$symbols$get;

        path.insertBefore(t().expressionStatement(t().assignmentExpression('=', t().clone(identifier), right)));
        let meta = (_asset$symbols$get = asset.symbols.get(name)) === null || _asset$symbols$get === void 0 ? void 0 : _asset$symbols$get.meta;

        if (meta != null) {
          meta.isPure = false;
        }
      }

      asset.meta.isCommonJS = true;
    }
  },

  UnaryExpression(path) {
    // Replace `typeof module` with "object"
    if (path.node.operator === 'typeof' && (0, t().isIdentifier)(path.node.argument) && TYPEOF[path.node.argument.name] && !path.scope.hasBinding(path.node.argument.name) && !path.scope.getData('shouldWrap')) {
      path.replaceWith(t().stringLiteral(TYPEOF[path.node.argument.name]));
    }
  },

  CallExpression(path, asset) {
    let {
      callee,
      arguments: args
    } = path.node;
    let [arg] = args;

    if (args.length !== 1 || !(0, t().isStringLiteral)(arg) || path.scope.hasBinding('require')) {
      return;
    }

    if ((0, t().isIdentifier)(callee, {
      name: 'require'
    })) {
      let source = arg.value; // Ignore require calls that were ignored earlier.

      let dep = asset.getDependencies().find(dep => dep.moduleSpecifier === source);

      if (!dep) {
        return;
      } // If this require call does not occur in the top-level, e.g. in a function
      // or inside an if statement, or if it might potentially happen conditionally,
      // the module must be wrapped in a function so that the module execution order is correct.


      if (!path.getStatementParent().parentPath.isProgram() || path.findParent(p => p.isConditionalExpression() || p.isLogicalExpression() || p.isFunction())) {
        dep.meta.shouldWrap = true;
      } // Generate a variable name based on the current asset id and the module name to require.
      // This will be replaced by the final variable name of the resolved asset in the packager.


      let replacement = REQUIRE_CALL_TEMPLATE({
        ID: t().stringLiteral(asset.id),
        SOURCE: t().stringLiteral(arg.value)
      });
      replacement.loc = path.node.loc;
      let memberAccesses;
      let properties;
      let propertyScope;
      let replacePath;
      let binding;
      let {
        parent
      } = path; // Try to statically analyze a dynamic import() call

      if (dep.isAsync) {
        let {
          parent: grandparent
        } = path.parentPath;

        if ((0, t().isMemberExpression)(parent, {
          object: path.node
        }) && (0, t().isIdentifier)(parent.property, {
          name: 'then'
        }) && (0, t().isCallExpression)(grandparent, {
          callee: parent
        }) && grandparent.arguments.length === 1 && (0, t().isFunction)(grandparent.arguments[0]) && // $FlowFixMe
        grandparent.arguments[0].params.length === 1) {
          let param = grandparent.arguments[0].params[0];

          if ((0, t().isObjectPattern)(param)) {
            // import(xxx).then(({ default: b }) => ...);
            properties = param.properties;
          } else if ((0, t().isIdentifier)(param)) {
            // import(xxx).then((ns) => ...);
            binding = path.parentPath.parentPath.get('arguments.0.body').scope.getBinding(param.name);
          }
        } else if ((0, t().isAwaitExpression)(parent, {
          argument: path.node
        })) {
          if ((0, t().isVariableDeclarator)(grandparent, {
            init: parent
          })) {
            if ((0, t().isObjectPattern)(grandparent.id)) {
              // let { x: y } = await import("./b.js");
              properties = grandparent.id.properties;
            } else if ((0, t().isIdentifier)(grandparent.id)) {
              // let ns = await import("./b.js");
              binding = path.parentPath.parentPath.scope.getBinding(grandparent.id.name);
            }
          } else if ( // ({ x: y } = await import("./b.js"));
          (0, t().isAssignmentExpression)(grandparent, {
            right: parent
          }) && (0, t().isObjectPattern)(grandparent.left)) {
            properties = grandparent.left.properties;
          }
        }
      } else if (isStaticMemberExpression(parent, {
        object: path.node
      })) {
        var _parent$property$name;

        // e.g. require('foo').bar
        // $FlowFixMe
        let name = (_parent$property$name = parent.property.name) !== null && _parent$property$name !== void 0 ? _parent$property$name : parent.property.value;
        memberAccesses = [{
          name,
          loc: (0, _babelAstUtils().convertBabelLoc)(parent.loc)
        }]; // If in an assignment expression, replace with a sequence expression
        // so that the $parcel$require is still in the correct position.
        // Otherwise, add a third argument to the $parcel$require call set to
        // the identifier to replace it with. This will be replaced in the linker.

        if ((0, t().isAssignmentExpression)(path.parentPath.parent, {
          left: parent
        })) {
          let assignment = t().cloneNode(path.parentPath.parent);
          assignment.left = t().identifier((0, _utils().getName)(asset, 'importAsync', dep.id, name));
          path.parentPath.parentPath.replaceWith(t().sequenceExpression([replacement, assignment]));
          replacement = null;
        } else {
          replacement.arguments.push(t().identifier((0, _utils().getName)(asset, 'importAsync', dep.id, name)));
          replacePath = path.parentPath;
        }
      } else if ((0, t().isVariableDeclarator)(parent, {
        init: path.node
      })) {
        if ((0, t().isObjectPattern)(parent.id)) {
          // let { x: y } = require("./b.js");
          properties = parent.id.properties;
          propertyScope = path.parentPath.parentPath.scope;
        } else if ((0, t().isIdentifier)(parent.id)) {
          // let ns = require("./b.js");
          binding = path.parentPath.parentPath.scope.getBinding(parent.id.name);
        }

        replacePath = path.parentPath;
      } else if ( // ({ x: y } = require("./b.js"));
      (0, t().isAssignmentExpression)(parent, {
        right: path.node
      }) && (0, t().isObjectPattern)(parent.left) && isUnusedValue(path.parentPath)) {
        properties = parent.left.properties;
        propertyScope = path.parentPath.scope;
        replacePath = path.parentPath;
      }

      if (properties != null && properties.length > 0 && properties.every(p => (0, t().isObjectProperty)(p) && (0, t().isIdentifier)(p.key))) {
        // take symbols listed when destructuring
        memberAccesses = properties.map(p => {
          (0, _assert().default)((0, t().isObjectProperty)(p));
          (0, _assert().default)((0, t().isIdentifier)(p.key));

          if (!dep.isAsync) {
            let name = p.key.name;
            let binding = propertyScope.getBinding(name);

            if (binding) {
              for (let ref of binding.referencePaths) {
                ref.replaceWith(t().identifier((0, _utils().getName)(asset, 'importAsync', dep.id, name)));
              }
            }
          }

          return {
            name: p.key.name,
            loc: (0, _babelAstUtils().convertBabelLoc)(p.loc)
          };
        });
      } else if (!path.scope.getData('shouldWrap') && // eval is evil
      binding != null && binding.constant && binding.referencePaths.length > 0 && binding.referencePaths.every(({
        parent,
        node
      }) => isStaticMemberExpression(parent, {
        object: node
      }))) {
        // properties of member expressions if all of them are static
        memberAccesses = binding.referencePaths.map(({
          parentPath,
          parent
        }) => {
          var _parent$property$name2;

          (0, _assert().default)((0, t().isMemberExpression)(parent)); // $FlowFixMe

          let name = (_parent$property$name2 = parent.property.name) !== null && _parent$property$name2 !== void 0 ? _parent$property$name2 : parent.property.value;

          if (!dep.isAsync) {
            parentPath.replaceWith(t().identifier((0, _utils().getName)(asset, 'importAsync', dep.id, name)));
          }

          return {
            // $FlowFixMe[prop-missing]
            name,
            loc: (0, _babelAstUtils().convertBabelLoc)(parent.loc)
          };
        });
      }

      dep.symbols.ensure();

      if (memberAccesses != null) {
        // The import() return value was statically analyzable
        for (let {
          name,
          loc
        } of (0, _nullthrows().default)(memberAccesses)) {
          dep.symbols.set(name, (0, _utils().getName)(asset, 'importAsync', dep.id, name), loc);
        }
      } else if (!isUnusedValue(path)) {
        // non-async and async fallback: everything
        dep.symbols.set('*', (0, _utils().getName)(asset, 'require', source), (0, _babelAstUtils().convertBabelLoc)(path.node.loc)); // Mark the dependency as CJS so that we keep the $id$exports var in the linker.

        dep.meta.isCommonJS = true;
      }

      if (memberAccesses != null && replacePath && replacement) {
        // Can't replace a variable declarator with a function call.
        // Need to replace the whole declaration.
        if ((0, t().isVariableDeclarator)(replacePath.node)) {
          let declaration = replacePath.parent;
          (0, _assert().default)((0, t().isVariableDeclaration)(declaration)); // If there is only one declarator, it's safe to replace the whole declaration.
          // Otherwise, split into multiple declarations so we can replace just one
          // with an expression statement containing the $parcel$require call.

          if (declaration.declarations.length === 1) {
            replacePath.parentPath.replaceWith(replacement);
          } else {
            let declIndex = declaration.declarations.indexOf(replacePath.node);
            replacePath.parentPath.insertBefore(t().variableDeclaration(declaration.kind, declaration.declarations.slice(0, declIndex)));
            replacePath.parentPath.insertBefore(t().expressionStatement(replacement));

            for (let i = declIndex; i >= 0; i--) {
              replacePath.parentPath.get(`declarations.${i}`).remove();
            }
          }
        } else {
          replacePath.replaceWith(replacement);
        }
      } else if (replacement) {
        path.replaceWith(replacement);
      }
    } else if (t().matchesPattern(callee, 'require.resolve')) {
      let replacement = REQUIRE_RESOLVE_CALL_TEMPLATE({
        ID: t().stringLiteral(asset.id),
        SOURCE: arg
      });
      replacement.loc = path.node.loc;
      path.replaceWith(replacement);
    }
  },

  ImportDeclaration(path, asset) {
    let dep = asset.getDependencies().find(dep => dep.moduleSpecifier === path.node.source.value);

    if (dep) {
      dep.meta.isES6Module = true;
      dep.symbols.ensure();
    } // For each specifier, rename the local variables to point to the imported name.
    // This will be replaced by the final variable name of the resolved asset in the packager.


    for (let specifier of path.node.specifiers) {
      let binding = (0, _nullthrows().default)(path.scope.getBinding(specifier.local.name)); // Ignore unused specifiers in node-modules, especially for when TS was poorly transpiled.

      if (!binding.referenced && !asset.isSource) {
        continue;
      }

      let id = (0, _utils().getIdentifier)(asset, 'import', specifier.local.name);

      if (dep) {
        // Try to resolve static member accesses to the namespace object
        // and transform them as though they were named imports.
        if ((0, t().isImportNamespaceSpecifier)(specifier)) {
          let bailedOut = false; // Clone array because we are modifying it in the loop

          for (let p of [...(0, _nullthrows().default)(path.scope.getBinding(specifier.local.name)).referencePaths]) {
            let {
              parent,
              node
            } = p;

            if ((0, t().isIdentifier)(node) && isStaticMemberExpression(parent, {
              object: node
            })) {
              var _parent$property$name3, _dep$symbols$get;

              let imported = // $FlowFixMe
              (_parent$property$name3 = parent.property.name) !== null && _parent$property$name3 !== void 0 ? _parent$property$name3 : parent.property.value;
              let id = (0, _utils().getIdentifier)(asset, 'import', specifier.local.name, imported);
              let existing = (_dep$symbols$get = dep.symbols.get(imported)) === null || _dep$symbols$get === void 0 ? void 0 : _dep$symbols$get.local;

              if (existing) {
                id.name = existing;
              }

              dep.symbols.set(imported, id.name, (0, _babelAstUtils().convertBabelLoc)(specifier.loc));
              (0, _utils().dereferenceIdentifier)(node, p.scope);
              p.parentPath.replaceWith(id);
            } else {
              // We can't replace this occurence and do need the namespace binding...
              bailedOut = true;
            }
          }

          if (bailedOut) {
            var _dep$symbols$get2;

            let existing = (_dep$symbols$get2 = dep.symbols.get('*')) === null || _dep$symbols$get2 === void 0 ? void 0 : _dep$symbols$get2.local;

            if (existing) {
              id.name = existing;
            }

            dep.symbols.set('*', id.name, (0, _babelAstUtils().convertBabelLoc)(specifier.loc));
          }
        } else {
          var _dep$symbols$get3;

          // mark this as a weak import:
          // import {x} from './c'; export {x};
          let isWeak = binding.referencePaths.length === 1 && (0, t().isExportSpecifier)(binding.referencePaths[0].parent, {
            local: binding.referencePaths[0].node
          });
          let imported;

          if ((0, t().isImportDefaultSpecifier)(specifier)) {
            imported = 'default'; // used in the CSS packager for CSS modules

            dep.meta.hasDefaultImport = true;
          } else if ((0, t().isImportSpecifier)(specifier)) {
            imported = specifier.imported.name;
          } else {
            throw new Error('Unknown import construct');
          }

          let existing = (_dep$symbols$get3 = dep.symbols.get(imported)) === null || _dep$symbols$get3 === void 0 ? void 0 : _dep$symbols$get3.local;

          if (existing) {
            id.name = existing;
          }

          dep.symbols.set(imported, id.name, (0, _babelAstUtils().convertBabelLoc)(specifier.loc), isWeak);
        }
      }

      (0, _renamer().default)(path.scope, specifier.local.name, id.name);
    }

    addImport(asset, path);
    path.remove();
  },

  ExportDefaultDeclaration(path, asset) {
    let {
      declaration,
      loc
    } = path.node;
    let identifier = (0, _utils().getExportIdentifier)(asset, 'default');
    let name;

    if (((0, t().isClassDeclaration)(declaration) || (0, t().isFunctionDeclaration)(declaration)) && declaration.id) {
      name = declaration.id.name;
    } else if ((0, t().isIdentifier)(declaration)) {
      name = declaration.name;
    }

    if (name && hasExport(asset, name)) {
      identifier = t().identifier(name);
    } // Add assignment to exports object for namespace imports and commonjs.


    path.insertAfter(EXPORT_TEMPLATE({
      EXPORTS: getExportsIdentifier(asset, path.scope),
      NAME: t().stringLiteral('default'),
      LOCAL: t().clone(identifier)
    }));

    if ((0, t().isIdentifier)(declaration) && path.scope.hasBinding(declaration.name,
    /* noGlobals */
    true)) {
      // Rename the variable being exported.
      safeRename(path, asset, declaration.name, identifier.name);
      path.remove();
    } else if ((0, t().isExpression)(declaration) || !declaration.id) {
      // $FlowFixMe[incompatible-call]
      let declarationExpr = t().toExpression(declaration); // Declare a variable to hold the exported value.

      path.replaceWith(t().variableDeclaration('var', [t().variableDeclarator(identifier, declarationExpr)]));
      path.scope.registerDeclaration(path);
    } else {
      (0, _assert().default)((0, t().isIdentifier)(declaration.id)); // Rename the declaration to the exported name.

      safeRename(path, asset, declaration.id.name, identifier.name);
      path.replaceWith(declaration);
    }

    if (!asset.symbols.hasExportSymbol('default')) {
      let binding = path.scope.getBinding(identifier.name);
      asset.symbols.set('default', identifier.name, (0, _babelAstUtils().convertBabelLoc)(loc), {
        isPure: isPure(binding)
      });
    }
  },

  ExportNamedDeclaration(path, asset) {
    let {
      declaration,
      source,
      specifiers
    } = path.node;

    if (source) {
      let dep = asset.getDependencies().find(dep => dep.moduleSpecifier === source.value);

      if (dep) {
        dep.meta.isES6Module = true;
        dep.symbols.ensure();
      }

      for (let specifier of (0, _nullthrows().default)(specifiers)) {
        let exported = specifier.exported;
        let imported;

        if ((0, t().isExportDefaultSpecifier)(specifier)) {
          imported = 'default';
        } else if ((0, t().isExportNamespaceSpecifier)(specifier)) {
          imported = '*';
        } else if ((0, t().isExportSpecifier)(specifier)) {
          imported = specifier.local.name;
        } else {
          throw new Error('Unknown export construct');
        }

        let id = (0, _utils().getIdentifier)(asset, 'import', exported.name);

        if (dep && imported) {
          var _dep$symbols$get4;

          let existing = (_dep$symbols$get4 = dep.symbols.get(imported)) === null || _dep$symbols$get4 === void 0 ? void 0 : _dep$symbols$get4.local;

          if (existing) {
            id.name = existing;
          }

          dep.symbols.set(imported, id.name, (0, _babelAstUtils().convertBabelLoc)(specifier.loc), true);
        }

        asset.symbols.set(exported.name, id.name, (0, _babelAstUtils().convertBabelLoc)(specifier.loc));
        id.loc = specifier.loc;
        path.insertAfter(EXPORT_TEMPLATE({
          EXPORTS: getExportsIdentifier(asset, path.scope),
          NAME: t().stringLiteral(exported.name),
          LOCAL: id
        }));
      }

      addImport(asset, path);
      path.remove();
    } else if (declaration) {
      if ((0, t().isIdentifier)(declaration.id)) {
        addExport(asset, path, declaration.id, declaration.id);
      } else {
        let identifiers = t().getBindingIdentifiers(declaration);

        for (let id of Object.keys(identifiers)) {
          addExport(asset, path, identifiers[id], identifiers[id]);
        }
      }

      path.replaceWith(declaration);
    } else {
      for (let specifier of specifiers) {
        (0, _assert().default)((0, t().isExportSpecifier)(specifier)); // because source is empty

        addExport(asset, path, specifier.local, specifier.exported);
      }

      path.remove();
    }
  },

  ExportAllDeclaration(path, asset) {
    let dep = asset.getDependencies().find(dep => dep.moduleSpecifier === path.node.source.value);

    if (dep) {
      dep.meta.isES6Module = true;
      dep.symbols.ensure();
      dep.symbols.set('*', '*', (0, _babelAstUtils().convertBabelLoc)(path.node.loc), true);
    }

    let replacement = EXPORT_ALL_TEMPLATE({
      OLD_NAME: getExportsIdentifier(asset, path.scope),
      SOURCE: t().stringLiteral(path.node.source.value),
      ID: t().stringLiteral(asset.id)
    });
    let {
      parentPath,
      scope
    } = path;
    path.remove(); // Make sure that the relative order of imports and reexports is retained.

    let lastImport = scope.getData('hoistedImport');

    if (lastImport) {
      [lastImport] = lastImport.insertAfter(replacement);
    } else {
      [lastImport] = parentPath.unshiftContainer('body', [replacement]);
    }

    path.scope.setData('hoistedImport', lastImport);
  }

};

function isPure(binding) {
  if (!binding || !binding.constant) {
    return false;
  }

  let references = binding.referencePaths.filter(reference => !reference.isExportDeclaration());

  if (references.length > 0) {
    return false;
  }

  let path = binding.path;

  if ((0, t().isVariableDeclarator)(path.node) && (0, t().isIdentifier)(path.node.id)) {
    let init = path.get('init');
    return init.isPure() || init.isIdentifier() || init.isThisExpression();
  }

  return path.isPure();
}

function addImport(asset, path) {
  // Replace with a $parcel$require call so we know where to insert side effects.
  let replacement = REQUIRE_CALL_TEMPLATE({
    ID: t().stringLiteral(asset.id),
    SOURCE: t().stringLiteral((0, _nullthrows().default)(path.node.source).value)
  });
  replacement.loc = path.node.loc;
  let requireStmt = t().expressionStatement(replacement); // Hoist the call to the top of the file.

  let lastImport = path.scope.getData('hoistedImport');

  if (lastImport) {
    [lastImport] = lastImport.insertAfter(requireStmt);
  } else {
    [lastImport] = path.parentPath.unshiftContainer('body', [requireStmt]);
  }

  path.scope.setData('hoistedImport', lastImport);
}

function addExport(asset, path, local, exported) {
  let scope = path.scope.getProgramParent();
  let identifier = (0, _utils().getExportIdentifier)(asset, exported.name);

  if (hasImport(asset, local.name)) {
    identifier = t().identifier(local.name);
  }

  if (hasExport(asset, local.name)) {
    identifier = t().identifier(local.name);
  }

  let assignNode = EXPORT_TEMPLATE({
    EXPORTS: getExportsIdentifier(asset, scope),
    NAME: t().stringLiteral(exported.name),
    LOCAL: identifier
  });

  if (!asset.symbols.hasExportSymbol(exported.name)) {
    let binding = scope.getBinding(local.name);
    asset.symbols.set(exported.name, identifier.name, (0, _babelAstUtils().convertBabelLoc)(exported.loc), {
      isPure: isPure(binding)
    });
  }

  (0, _renamer().default)(scope, local.name, identifier.name);
  path.insertAfter(t().cloneDeep(assignNode));
}

function hasImport(asset, id) {
  for (let dep of asset.getDependencies()) {
    if (dep.symbols.hasLocalSymbol(id)) {
      return true;
    }
  }

  return false;
}

function hasExport(asset, id) {
  return asset.symbols.hasLocalSymbol(id);
}

function safeRename(path, asset, from, to) {
  if (from === to) {
    return;
  } // If the binding that we're renaming is constant, it's safe to rename it.
  // Otherwise, create a new binding that references the original.


  let binding = (0, _nullthrows().default)(path.scope.getBinding(from));

  if (binding && binding.constant) {
    (0, _renamer().default)(path.scope, from, to);
  } else {
    let [decl] = path.insertAfter(t().variableDeclaration('var', [t().variableDeclarator(t().identifier(to), t().identifier(from))]));
    binding.reference(decl.get('declarations.0.init'));
    path.scope.registerDeclaration(decl);
  }
}

function getExportsIdentifier(asset, scope) {
  if (scope.getProgramParent().getData('shouldWrap')) {
    return t().identifier('exports');
  } else {
    let id = (0, _utils().getIdentifier)(asset, 'exports');

    if (!scope.hasBinding(id.name)) {
      scope.getProgramParent().addGlobal(id);
    }

    return id;
  }
}

function getCJSExportsIdentifier(asset, scope) {
  if (scope.getProgramParent().getData('shouldWrap')) {
    return t().identifier('exports');
  } else if (scope.getProgramParent().getData('cjsExportsReassigned')) {
    let id = (0, _utils().getIdentifier)(asset, 'cjs_exports');

    if (!scope.hasBinding(id.name)) {
      scope.getProgramParent().push({
        id
      });
    }

    return id;
  } else {
    return getExportsIdentifier(asset, scope);
  }
}

function isUnusedValue(path) {
  let {
    parent
  } = path;
  return (0, t().isExpressionStatement)(parent) || (0, t().isSequenceExpression)(parent) && (Array.isArray(path.container) && path.key !== path.container.length - 1 || isUnusedValue(path.parentPath));
}

function addSelfReference(path, asset) {
  // If referencing a property on this/exports/module.exports, create a self-referencing dependency
  // to track that the symbol is used, and replace the member expression with.
  if (isStaticMemberExpression(path.parent, {
    object: path.node
  }) && !(0, t().isAssignmentExpression)(path.parentPath.parent, {
    left: path.parent
  })) {
    var _path$parent$property;

    // $FlowFixMe
    let name = (_path$parent$property = path.parent.property.name) !== null && _path$parent$property !== void 0 ? _path$parent$property : path.parent.property.value; // Do not create a self-reference for the `default` symbol unless we have seen an __esModule flag.

    if (name === 'default' && !asset.symbols.hasExportSymbol('__esModule')) {
      return;
    }

    let local = (0, _utils().getExportIdentifier)(asset, name);
    asset.addDependency({
      moduleSpecifier: `./${(0, _path().basename)(asset.filePath)}`,
      symbols: new Map([[name, {
        local: local.name,
        isWeak: false,
        loc: (0, _babelAstUtils().convertBabelLoc)(path.node.loc)
      }]])
    });
    return local;
  }
}

function isStaticMemberExpression(node, opts) {
  return (0, t().isMemberExpression)(node, opts) && ((0, t().isIdentifier)(node.property) && !node.computed || (0, t().isStringLiteral)(node.property));
}