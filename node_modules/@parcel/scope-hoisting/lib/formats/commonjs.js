"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateBundleImports = generateBundleImports;
exports.generateExternalImport = generateExternalImport;
exports.generateBundleExports = generateBundleExports;
exports.generateMainExport = generateMainExport;

function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function () {
    return data;
  };

  return data;
}

function _template() {
  const data = _interopRequireDefault(require("@babel/template"));

  _template = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _utils2() {
  const data = require("../utils");

  _utils2 = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const REQUIRE_TEMPLATE = _template().default.expression('require(BUNDLE)');

const EXPORT_TEMPLATE = _template().default.statement('exports.NAME = IDENTIFIER;');

const MODULE_EXPORTS_TEMPLATE = _template().default.statement('module.exports = IDENTIFIER;');

const INTEROP_TEMPLATE = _template().default.expression('$parcel$interopDefault(MODULE)');

const ASSIGN_TEMPLATE = _template().default.statement('var SPECIFIERS = MODULE;');

const NAMESPACE_TEMPLATE = _template().default.expression('$parcel$exportWildcard(NAMESPACE, MODULE)'); // List of engines that support object destructuring syntax


const DESTRUCTURING_ENGINES = {
  chrome: '51',
  edge: '15',
  firefox: '53',
  safari: '10',
  node: '6.5',
  ios: '10',
  samsung: '5',
  opera: '38',
  electron: '1.2'
};

function generateDestructuringAssignment(env, specifiers, value, scope) {
  // If destructuring is not supported, generate a series of variable declarations
  // with member expressions for each property.
  if (!env.matchesEngines(DESTRUCTURING_ENGINES)) {
    let statements = [];

    if (!(0, t().isIdentifier)(value) && specifiers.length > 1) {
      let name = scope.generateUid();
      statements.push(ASSIGN_TEMPLATE({
        SPECIFIERS: t().identifier(name),
        MODULE: value
      }));
      value = t().identifier(name);
    }

    for (let specifier of specifiers) {
      (0, _assert().default)((0, t().isIdentifier)(specifier.value));
      statements.push(ASSIGN_TEMPLATE({
        SPECIFIERS: specifier.value,
        MODULE: t().memberExpression(value, specifier.key)
      }));
    }

    return statements;
  }

  return [ASSIGN_TEMPLATE({
    SPECIFIERS: t().objectPattern(specifiers),
    MODULE: value
  })];
}

function generateBundleImports(bundleGraph, from, {
  bundle,
  assets
}, scope) {
  let specifiers = [...assets].map(asset => {
    let id = (0, _utils2().getName)(asset, 'init');
    return t().objectProperty(t().identifier(id), t().identifier(id), false, true);
  });
  let expression = REQUIRE_TEMPLATE({
    BUNDLE: t().stringLiteral((0, _utils().relativeBundlePath)(from, bundle))
  });

  if (specifiers.length > 0) {
    return {
      imports: generateDestructuringAssignment(bundle.env, specifiers, expression, scope),
      hoisted: []
    };
  } else {
    return {
      imports: [t().expressionStatement(expression)],
      hoisted: []
    };
  }
}

function generateExternalImport(bundle, external, scope) {
  let {
    source,
    specifiers,
    isCommonJS
  } = external;
  let properties = [];
  let categories = new Set();

  for (let [imported, symbol] of specifiers) {
    if (imported === '*') {
      categories.add('namespace');
    } else if (imported === 'default') {
      categories.add('default');
    } else {
      categories.add('named');
      properties.push(t().objectProperty(t().identifier(imported), t().identifier(symbol), false, symbol === imported));
    }
  }

  let specifiersWildcard = specifiers.get('*');
  let specifiersDefault = specifiers.get('default');
  let statements = []; // Attempt to combine require calls as much as possible. Namespace, default, and named specifiers
  // cannot be combined, so in the case where we have more than one type, assign the require() result
  // to a variable first and then create additional variables for each specifier based on that.
  // Otherwise, if just one category is imported, just assign and require all at once.

  if (categories.size > 1) {
    let name = scope.generateUid(source);
    statements.push(ASSIGN_TEMPLATE({
      SPECIFIERS: t().identifier(name),
      MODULE: REQUIRE_TEMPLATE({
        BUNDLE: t().stringLiteral(source)
      })
    }));

    if (specifiersWildcard) {
      let value = t().identifier(name);

      if (!isCommonJS) {
        value = NAMESPACE_TEMPLATE({
          NAMESPACE: t().objectExpression([]),
          MODULE: value
        });
        scope.add('$parcel$exportWildcard');
      }

      statements.push(ASSIGN_TEMPLATE({
        SPECIFIERS: t().identifier(specifiersWildcard),
        MODULE: value
      }));
    }

    if (specifiersDefault) {
      statements.push(ASSIGN_TEMPLATE({
        SPECIFIERS: t().identifier(specifiersDefault),
        MODULE: INTEROP_TEMPLATE({
          MODULE: t().identifier(name)
        })
      }));
      scope.add('$parcel$interopDefault');
    }

    if (properties.length > 0) {
      statements.push(...generateDestructuringAssignment(bundle.env, properties, t().identifier(name), scope));
    }
  } else if (specifiersDefault) {
    statements.push(ASSIGN_TEMPLATE({
      SPECIFIERS: t().identifier(specifiersDefault),
      MODULE: INTEROP_TEMPLATE({
        MODULE: REQUIRE_TEMPLATE({
          BUNDLE: t().stringLiteral(source)
        })
      })
    }));
    scope.add('$parcel$interopDefault');
  } else if (specifiersWildcard) {
    let require = REQUIRE_TEMPLATE({
      BUNDLE: t().stringLiteral(source)
    });

    if (!isCommonJS) {
      require = NAMESPACE_TEMPLATE({
        NAMESPACE: t().objectExpression([]),
        MODULE: require
      });
      scope.add('$parcel$exportWildcard');
    }

    statements.push(ASSIGN_TEMPLATE({
      SPECIFIERS: t().identifier(specifiersWildcard),
      MODULE: require
    }));
  } else if (properties.length > 0) {
    statements.push(...generateDestructuringAssignment(bundle.env, properties, REQUIRE_TEMPLATE({
      BUNDLE: t().stringLiteral(source)
    }), scope));
  } else {
    statements.push(t().expressionStatement(REQUIRE_TEMPLATE({
      BUNDLE: t().stringLiteral(source)
    })));
  }

  return statements;
}

function generateBundleExports(bundleGraph, bundle, referencedAssets, scope, reexports) {
  let exported = new Set();
  let statements = [];

  for (let asset of referencedAssets) {
    let id = (0, _utils2().getIdentifier)(asset, 'init');
    exported.add(id.name);
    statements.push(EXPORT_TEMPLATE({
      NAME: id,
      IDENTIFIER: id
    }));
  }

  for (let exp of reexports) {
    statements.push(EXPORT_TEMPLATE({
      NAME: t().identifier(exp.exportAs),
      IDENTIFIER: t().identifier(exp.local)
    }));
  }

  return statements;
}

function generateMainExport(node, exported) {
  let statements = [node];

  for (let {
    exportAs,
    local
  } of exported) {
    if (exportAs === '*') {
      // Replace assignments to the `exports` object with `module.exports`
      if ((0, t().isExpressionStatement)(node)) {
        let expression = node.expression;
        (0, _assert().default)((0, t().isAssignmentExpression)(expression));
        expression.left = t().memberExpression(t().identifier('module'), t().identifier('exports'));
        continue;
      } // Remove the `exports` declaration if set to an empty object.
      // Otherwise, assign to `module.exports`.


      let isExports = false;

      if ((0, t().isVariableDeclaration)(node)) {
        let decl = node.declarations.find(decl => (0, t().isIdentifier)(decl.id) && decl.id.name === local);
        isExports = decl && decl.init && (0, t().isObjectExpression)(decl.init) && decl.init.properties.length === 0;
      }

      if (!isExports) {
        statements.push(MODULE_EXPORTS_TEMPLATE({
          IDENTIFIER: t().identifier(local)
        }));
      } else {
        statements.shift();
      }
    } else {
      // Exports other than the default export are live bindings.
      // Only insert an assignment to module.exports for non-default exports.
      if ((0, t().isExpressionStatement)(node) && exportAs === 'default') {
        continue;
      }

      statements.push(EXPORT_TEMPLATE({
        NAME: t().identifier(exportAs),
        IDENTIFIER: t().identifier(local)
      }));
    }
  }

  return statements;
}