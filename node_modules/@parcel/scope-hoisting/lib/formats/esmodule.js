"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateBundleImports = generateBundleImports;
exports.generateExternalImport = generateExternalImport;
exports.generateBundleExports = generateBundleExports;
exports.generateMainExport = generateMainExport;

function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function () {
    return data;
  };

  return data;
}

function _template() {
  const data = _interopRequireDefault(require("@babel/template"));

  _template = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _utils2() {
  const data = require("../utils");

  _utils2 = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const DEFAULT_INTEROP_TEMPLATE = _template().default.statement('var NAME = $parcel$interopDefault(MODULE);');

function generateBundleImports(bundleGraph, from, {
  bundle,
  assets
}, // eslint-disable-next-line no-unused-vars
scope) {
  let specifiers = [];
  let interops = [];

  for (let asset of assets) {
    let id = (0, _utils2().getName)(asset, 'init');
    specifiers.push(t().importSpecifier(t().identifier(id), t().identifier(id)));

    if (asset.meta.isCommonJS === true) {
      let deps = bundleGraph.getIncomingDependencies(asset);
      let hasDefaultInterop = deps.some(dep => dep.symbols.hasExportSymbol('default') && from.hasDependency(dep));

      if (hasDefaultInterop) {
        interops.push(DEFAULT_INTEROP_TEMPLATE({
          NAME: (0, _utils2().getIdentifier)(asset, '$interop$default'),
          MODULE: t().callExpression((0, _utils2().getIdentifier)(asset, 'init'), [])
        }));
        scope.add('$parcel$interopDefault');
      }
    }
  }

  return {
    hoisted: [t().importDeclaration(specifiers, t().stringLiteral((0, _utils().relativeBundlePath)(from, bundle))), ...interops],
    imports: []
  };
}

function generateExternalImport(bundle, external) {
  let {
    source,
    specifiers,
    isCommonJS
  } = external;
  let defaultSpecifier = null;
  let namespaceSpecifier = null;
  let namedSpecifiers = [];

  for (let [imported, symbol] of specifiers) {
    if (imported === 'default' || isCommonJS) {
      defaultSpecifier = t().importDefaultSpecifier(t().identifier(symbol));
    } else if (imported === '*') {
      namespaceSpecifier = t().importNamespaceSpecifier(t().identifier(symbol));
    } else {
      namedSpecifiers.push(t().importSpecifier(t().identifier(symbol), t().identifier(imported)));
    }
  }

  let statements = []; // ESModule syntax allows combining default and namespace specifiers, or default and named, but not all three.

  if (namespaceSpecifier) {
    let s = [namespaceSpecifier];

    if (defaultSpecifier) {
      s.unshift(defaultSpecifier);
    }

    statements.push(t().importDeclaration(s, t().stringLiteral(source)));
  } else if (defaultSpecifier) {
    namedSpecifiers.unshift(defaultSpecifier);
  }

  if (namedSpecifiers.length > 0 || statements.length === 0) {
    statements.push(t().importDeclaration(namedSpecifiers, t().stringLiteral(source)));
  }

  return statements;
}

function generateBundleExports(bundleGraph, bundle, referencedAssets, scope, reexports) {
  let statements = [];

  if (referencedAssets.size > 0 || reexports.size > 0) {
    statements.push(t().exportNamedDeclaration(null, [...referencedAssets].map(asset => {
      let name = (0, _utils2().getName)(asset, 'init');
      return t().exportSpecifier(t().identifier(name), t().identifier(name));
    }).concat([...reexports].map(exp => t().exportSpecifier(t().identifier(exp.local), t().identifier(exp.exportAs))))));
  } // If the main entry is a CommonJS asset, export its `module.exports` property as the `default` export


  let entry = bundle.getMainEntry();

  if ((entry === null || entry === void 0 ? void 0 : entry.meta.isCommonJS) === true) {
    statements.push(t().exportDefaultDeclaration(t().identifier((0, _utils2().assertString)(entry.meta.exportsIdentifier))));
  }

  return statements;
}

function generateMainExport(node, exported) {
  if ((0, t().isExpressionStatement)(node)) {
    return [node];
  }

  let statements = [];
  let bindingIdentifiers = t().getBindingIdentifiers(node);
  let ids = Object.keys(bindingIdentifiers); // Export '*' (re-exported CJS exports object) as default

  let defaultExport = exported.find(e => e.exportAs === 'default' || e.exportAs === '*');
  let namedExports = exported.filter(e => e.exportAs !== 'default' && e.exportAs !== '*');

  if (exported.length === 1 && defaultExport && !(0, t().isVariableDeclaration)(node)) {
    // If there's only a default export, then export the declaration directly.
    // $FlowFixMe - we don't need to worry about type declarations here.
    statements.push(t().exportDefaultDeclaration(node));
  } else if (namedExports.length === exported.length && namedExports.length === ids.length && namedExports.every(({
    exportAs,
    local
  }) => exportAs === local)) {
    // If there's only named exports, all of the ids are exported,
    // and none of them are renamed, export the declaration directly.
    statements.push(t().exportNamedDeclaration(node, []));
  } else {
    // Otherwise, add a default export and named export for the identifiers after the original declaration.
    statements.push(node);

    if (defaultExport) {
      statements.push(t().exportDefaultDeclaration(t().identifier(defaultExport.local)));
    }

    if (namedExports.length > 0) {
      statements.push(t().exportNamedDeclaration(null, namedExports.map(e => t().exportSpecifier(t().identifier(e.local), t().identifier(e.exportAs)))));
    }
  }

  return statements;
}