"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateBundleImports = generateBundleImports;
exports.generateExternalImport = generateExternalImport;
exports.generateBundleExports = generateBundleExports;
exports.generateMainExport = generateMainExport;

function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function () {
    return data;
  };

  return data;
}

function _template() {
  const data = _interopRequireDefault(require("@babel/template"));

  _template = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _utils2() {
  const data = require("../utils");

  _utils2 = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const IMPORT_TEMPLATE = _template().default.statement('var NAME = parcelRequire(ASSET_ID);');

const EXPORT_TEMPLATE = _template().default.statement('parcelRequire.register(ASSET_ID, IDENTIFIER)');

const EXPORT_FN_TEMPLATE = _template().default.statement('parcelRequire.register(ASSET_ID, function() { return IDENTIFIER; })');

const IMPORTSCRIPTS_TEMPLATE = _template().default.statement('importScripts(BUNDLE);');

const DEFAULT_INTEROP_TEMPLATE = _template().default.statement('var NAME = $parcel$interopDefault(MODULE);');

function generateBundleImports(bundleGraph, from, {
  bundle,
  assets
}, scope) {
  let hoisted = [];

  if (from.env.isWorker()) {
    hoisted.push(IMPORTSCRIPTS_TEMPLATE({
      BUNDLE: t().stringLiteral((0, _utils().relativeBundlePath)(from, bundle))
    }));
  }

  let imports = [];

  for (let asset of assets) {
    imports.push(IMPORT_TEMPLATE({
      NAME: (0, _utils2().getIdentifier)(asset, 'init'),
      ASSET_ID: t().stringLiteral(bundleGraph.getAssetPublicId(asset))
    }));
    scope.add('$parcel$global');
    scope.add('parcelRequire');

    if (asset.meta.isCommonJS) {
      let deps = bundleGraph.getIncomingDependencies(asset);
      let hasDefaultInterop = deps.some(dep => dep.symbols.hasExportSymbol('default') && from.hasDependency(dep));

      if (hasDefaultInterop) {
        imports.push(DEFAULT_INTEROP_TEMPLATE({
          NAME: (0, _utils2().getIdentifier)(asset, '$interop$default'),
          MODULE: t().callExpression((0, _utils2().getIdentifier)(asset, 'init'), [])
        }));
        scope.add('$parcel$interopDefault');
      }
    }
  }

  return {
    imports,
    hoisted
  };
}

function generateExternalImport( // eslint-disable-next-line no-unused-vars
bundle, {
  loc
}) {
  throw (0, _utils2().getThrowableDiagnosticForNode)('External modules are not supported when building for browser', loc === null || loc === void 0 ? void 0 : loc.filePath, loc);
}

function generateBundleExports(bundleGraph, bundle, referencedAssets, scope) {
  let statements = [];

  for (let asset of referencedAssets) {
    let exportsId = (0, _utils2().getName)(asset, 'init');
    statements.push(EXPORT_TEMPLATE({
      ASSET_ID: t().stringLiteral(bundleGraph.getAssetPublicId(asset)),
      IDENTIFIER: t().identifier(exportsId)
    }));
    scope.add('$parcel$global');
    scope.add('parcelRequire');
  }

  let entry = bundle.getMainEntry();

  if (entry && !referencedAssets.has(entry) && (!(0, _utils2().isEntry)(bundle, bundleGraph) || (0, _utils2().isReferenced)(bundle, bundleGraph))) {
    statements.push( // Export a function returning the exports, as other cases of global output
    // register init functions.
    EXPORT_FN_TEMPLATE({
      ASSET_ID: t().stringLiteral(bundleGraph.getAssetPublicId(entry)),
      IDENTIFIER: t().identifier((0, _utils2().assertString)(entry.meta.exportsIdentifier))
    }));
    scope.add('$parcel$global');
    scope.add('parcelRequire');
  }

  return statements;
}

function generateMainExport(node) {
  return [node];
}