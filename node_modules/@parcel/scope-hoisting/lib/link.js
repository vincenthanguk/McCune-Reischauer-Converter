"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.link = link;

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireWildcard(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _template() {
  const data = _interopRequireDefault(require("@babel/template"));

  _template = function () {
    return data;
  };

  return data;
}

function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = require("@parcel/diagnostic");

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _babylonWalk() {
  const data = require("@parcel/babylon-walk");

  _babylonWalk = function () {
    return data;
  };

  return data;
}

function _babelAstUtils() {
  const data = require("@parcel/babel-ast-utils");

  _babelAstUtils = function () {
    return data;
  };

  return data;
}

function _globals() {
  const data = _interopRequireDefault(require("globals"));

  _globals = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("./utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _index() {
  const data = _interopRequireDefault(require("./formats/index.js"));

  _index = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const THROW_TEMPLATE = _template().default.statement('$parcel$missingModule(MODULE);');

const REQUIRE_RESOLVE_CALL_TEMPLATE = _template().default.expression('require.resolve(ID)');

const FAKE_INIT_TEMPLATE = _template().default.statement(`function INIT(){
  return EXPORTS;
}`);

const PARCEL_REQUIRE_TEMPLATE = _template().default.statement(`var parcelRequire = $parcel$global.PARCEL_REQUIRE_NAME`);

const PARCEL_REQUIRE_NAME_TEMPLATE = _template().default.statement(`var parcelRequireName = PARCEL_REQUIRE_NAME;`);

const BUILTINS = Object.keys(_globals().default.builtin);
const GLOBALS_BY_CONTEXT = {
  browser: new Set([...BUILTINS, ...Object.keys(_globals().default.browser)]),
  'web-worker': new Set([...BUILTINS, ...Object.keys(_globals().default.worker)]),
  'service-worker': new Set([...BUILTINS, ...Object.keys(_globals().default.serviceworker)]),
  node: new Set([...BUILTINS, ...Object.keys(_globals().default.node)]),
  'electron-main': new Set([...BUILTINS, ...Object.keys(_globals().default.node)]),
  'electron-renderer': new Set([...BUILTINS, ...Object.keys(_globals().default.node), ...Object.keys(_globals().default.browser)])
};

const PRELUDE_PATH = _path().default.join(__dirname, 'prelude.js');

const PRELUDE = (0, _utils().parse)(_fs().default.readFileSync(_path().default.join(__dirname, 'prelude.js'), 'utf8'), PRELUDE_PATH);

const REGISTER_TEMPLATE = _template().default.statements(`function $parcel$bundleWrapper() {
  if ($parcel$bundleWrapper._executed) return;
  $parcel$bundleWrapper._executed = true;
  STATEMENTS;
}
var $parcel$referencedAssets = REFERENCED_IDS;
for (var $parcel$i = 0; $parcel$i < $parcel$referencedAssets.length; $parcel$i++) {
  PARCEL_REQUIRE.registerBundle($parcel$referencedAssets[$parcel$i], $parcel$bundleWrapper);
}
`);

const WRAPPER_TEMPLATE = _template().default.statement('(function () { STATEMENTS; })()');

function link({
  bundle,
  bundleGraph,
  ast,
  options,
  wrappedAssets,
  parcelRequireName
}) {
  let format = _index().default[bundle.env.outputFormat];

  let replacements = new Map();
  let imports = new Map();
  let exports = new Map();
  let assets = new Map();
  let exportsMap = new Map();
  let scope = new (_babylonWalk().Scope)('program');
  let globalNames = GLOBALS_BY_CONTEXT[bundle.env.context];
  let helpers = (0, _utils().getHelpers)();
  let importedFiles = new Map();
  let referencedAssets = new Set();
  let reexports = new Set(); // If building a library, the target is actually another bundler rather
  // than the final output that could be loaded in a browser. So, loader
  // runtimes are excluded, and instead we add imports into the entry bundle
  // of each bundle group pointing at the sibling bundles. These can be
  // picked up by another bundler later at which point runtimes will be added.

  if (bundle.env.isLibrary) {
    let bundles = bundleGraph.getReferencedBundles(bundle);

    for (let b of bundles) {
      importedFiles.set((0, _nullthrows().default)(b.filePath), {
        bundle: b,
        assets: new Set()
      });
    }
  } // Build a mapping of all imported identifiers to replace.


  bundle.traverseAssets(asset => {
    assets.set((0, _utils().assertString)(asset.meta.id), asset);
    exportsMap.set((0, _utils().assertString)(asset.meta.exportsIdentifier), asset);

    for (let dep of bundleGraph.getDependencies(asset)) {
      let resolved = bundleGraph.getDependencyResolution(dep, bundle);
      let skipped = bundleGraph.isDependencySkipped(dep); // If the dependency was skipped, the `...$import$..` identifier needs to be removed.
      // If the dependency was excluded, it will be replaced by the output format at the very end.

      if (resolved || skipped) {
        for (let [imported, {
          local,
          loc
        }] of dep.symbols) {
          imports.set(local, resolved && !skipped ? [resolved, imported, loc] : null);
        }
      }
    }

    for (let [symbol, {
      local
    }] of asset.symbols) {
      exports.set(local, [asset, symbol]);
    }

    if (bundleGraph.isAssetReferencedByDependant(bundle, asset)) {
      referencedAssets.add(asset);
    }
  });
  let entry = bundle.getMainEntry();
  let exportedSymbols = new Map();

  if (entry) {
    if (entry.meta.isCommonJS) {
      if (bundle.env.outputFormat === 'commonjs') {
        exportedSymbols.set((0, _utils().assertString)(entry.meta.exportsIdentifier), [{
          exportAs: '*',
          local: 'exports'
        }]);
      }
    } else {
      for (let {
        exportAs,
        exportSymbol,
        symbol,
        asset,
        loc
      } of bundleGraph.getExportedSymbols(entry)) {
        if (typeof symbol === 'string') {
          let symbols = exportedSymbols.get(symbol === '*' ? (0, _utils().assertString)(entry.meta.exportsIdentifier) : symbol);
          let local = exportAs;

          if (symbols) {
            local = symbols[0].local;
          } else {
            symbols = [];
            exportedSymbols.set(symbol, symbols);

            if (local === '*') {
              local = 'exports';
            } else if (!t().isValidIdentifier(local) || globalNames.has(local)) {
              local = scope.generateUid(local);
            } else {
              scope.add(local);
            }
          }

          symbols.push({
            exportAs,
            local
          });
        } else if (symbol === null) {
          // TODO `meta.exportsIdentifier[exportSymbol]` should be exported
          let relativePath = (0, _path().relative)(options.projectRoot, asset.filePath);
          throw (0, _utils().getThrowableDiagnosticForNode)((0, _diagnostic().md)`${relativePath} couldn't be statically analyzed when importing '${exportSymbol}'`, entry.filePath, loc);
        } else if (symbol !== false) {
          let relativePath = (0, _path().relative)(options.projectRoot, asset.filePath);
          throw (0, _utils().getThrowableDiagnosticForNode)((0, _diagnostic().md)`${relativePath} does not export '${exportSymbol}'`, entry.filePath, loc);
        }
      }
    }
  }

  let resolveSymbolCache = new Map();

  function resolveSymbol(inputAsset, inputSymbol, bundle) {
    let k = inputAsset.id + ':' + inputSymbol + ':' + bundle.id;
    let cached = resolveSymbolCache.get(k);

    if (cached) {
      return cached;
    }

    let {
      asset,
      exportSymbol,
      symbol,
      loc
    } = bundleGraph.resolveSymbol(inputAsset, inputSymbol, bundle);

    if (asset.meta.staticExports === false) {
      let res = {
        asset: asset,
        symbol: exportSymbol,
        identifier: null,
        loc
      };
      resolveSymbolCache.set(k, res);
      return res;
    }

    let identifier = symbol;

    if (identifier && imports.get(identifier) === null) {
      // a deferred import
      let res = {
        asset: asset,
        symbol: exportSymbol,
        identifier: null,
        loc
      };
      resolveSymbolCache.set(k, res);
      return res;
    } // If this is a wildcard import, resolve to the exports object.


    if (asset && exportSymbol === '*') {
      identifier = (0, _utils().assertString)(asset.meta.exportsIdentifier);
    }

    if (identifier && replacements.has(identifier)) {
      identifier = replacements.get(identifier);
    }

    let res = {
      asset: asset,
      symbol: exportSymbol,
      identifier,
      loc
    };
    resolveSymbolCache.set(k, res);
    return res;
  }

  let needsExportsIdentifierCache = new Map();
  let bundleNeedsMainExportsIdentifier = bundle.env.outputFormat === 'global' && (!(0, _utils().isEntry)(bundle, bundleGraph) || (0, _utils().isReferenced)(bundle, bundleGraph)) || bundle.env.outputFormat === 'esmodule' && (entry === null || entry === void 0 ? void 0 : entry.meta.isCommonJS);

  function needsExportsIdentifier(name) {
    let asset = exportsMap.get(name);

    if (asset) {
      return needsExportsIdentifierForAsset(asset);
    }

    return true;
  }

  function needsExportsIdentifierForAsset(asset) {
    if (needsExportsIdentifierCache.has(asset)) {
      return needsExportsIdentifierCache.get(asset);
    }

    if (asset.meta.staticExports === false || wrappedAssets.has(asset.id) || referencedAssets.has(asset)) {
      needsExportsIdentifierCache.set(asset, true);
      return true;
    }

    let isEntry = asset === bundle.getMainEntry();

    if (isEntry && bundleNeedsMainExportsIdentifier) {
      needsExportsIdentifierCache.set(asset, true);
      return true;
    }

    let deps = bundleGraph.getIncomingDependencies(asset);
    let usedSymbols = bundleGraph.getUsedSymbols(asset);

    if (usedSymbols.has('*') && (!isEntry || asset.meta.isCommonJS)) {
      needsExportsIdentifierCache.set(asset, true);
      return true;
    }

    let res = deps.some(dep => // Internalized async dependencies need the exports object for Promise.resolve($id$exports)
    dep.isAsync && bundle.hasDependency(dep) || // If there's a dependency on the namespace, and the parent asset's exports object is used,
    // we need to keep the exports object for $parcel$exportWildcard.
    !isEntry && dep.symbols.hasExportSymbol('*') && needsExportsIdentifierForAsset((0, _nullthrows().default)(bundleGraph.getAssetWithDependency(dep))) || // If the asset is CommonJS and there's an ES6 dependency on `default`, we need the
    // exports identifier to call $parcel$interopDefault.
    asset.meta.isCommonJS && dep.meta.isES6Module && dep.symbols.hasExportSymbol('default') || // If the asset is an ES6 module with a default export, and there's a CommonJS dependency
    // on it, we need the exports identifier to call $parcel$defineInteropFlag.
    asset.meta.isES6Module && asset.symbols.hasExportSymbol('default') && dep.meta.isCommonJS && !dep.isAsync && dep.symbols.hasExportSymbol('*') || // If one of the symbols imported by the dependency doesn't resolve, then we need the
    // exports identifier to fall back to.
    [...dep.symbols].some(([symbol]) => !resolveSymbol(asset, symbol, bundle).identifier));
    needsExportsIdentifierCache.set(asset, res);
    return res;
  }

  function needsDeclaration(name) {
    let exp = exports.get(name);

    if (exp) {
      var _asset$symbols$get, _asset$symbols$get$me;

      let [asset, local] = exp;

      if (asset === bundle.getMainEntry() && bundle.env.isLibrary) {
        return true;
      }

      if (asset.meta.staticExports === false) {
        return true;
      }

      let usedSymbols = bundleGraph.getUsedSymbols(asset); // If the asset is CommonJS, and "default" was used but not defined, this
      // will resolve to the $id$exports object, so we need to retain all symbols.

      if (asset.meta.isCommonJS && usedSymbols.has('default') && !asset.symbols.hasExportSymbol('default')) {
        return true;
      } // Otherwise, if the symbol is pure and unused, it is safe to remove.


      if ((_asset$symbols$get = asset.symbols.get(local)) !== null && _asset$symbols$get !== void 0 && (_asset$symbols$get$me = _asset$symbols$get.meta) !== null && _asset$symbols$get$me !== void 0 && _asset$symbols$get$me.isPure) {
        return usedSymbols.has(local) || usedSymbols.has('*');
      }
    }

    return true;
  }

  function maybeReplaceIdentifier(node) {
    let {
      name
    } = node;

    if (typeof name !== 'string') {
      return;
    }

    let replacement = replacements.get(name);

    if (replacement) {
      node.name = replacement;
    }

    if (imports.has(name)) {
      let res;
      let imported = imports.get(name);

      if (imported == null) {
        // import was deferred
        res = t().objectExpression([]);
      } else {
        let [asset, symbol] = imported;
        res = replaceImportNode(asset, symbol, node); // If the export does not exist, replace with an empty object.

        if (!res) {
          res = t().objectExpression([]);
        }
      }

      return res;
    }
  } // node is an Identifier like $id$import$foo that directly imports originalName from originalModule


  function replaceImportNode(originalModule, originalName, node) {
    let {
      asset: mod,
      symbol,
      identifier
    } = resolveSymbol(originalModule, originalName, bundle); // If the symbol resolves to the original module where the export is defined,
    // do not perform any replacements.

    let exp = exports.get(node.name);

    if (exp && exp[0] === mod) {
      return node;
    }

    let res = identifier != null ? findSymbol(node, identifier) : identifier;

    if (mod.meta.staticExports === false || wrappedAssets.has(mod.id)) {
      res = null;
    } // If the module is not in this bundle, create a `require` call for it.


    if (!mod.meta.id || !assets.has((0, _utils().assertString)(mod.meta.id))) {
      if (res === false) {
        // Asset was skipped
        return null;
      }

      res = addBundleImport(mod, node);
      return res ? interop(mod, symbol, node, res) : null;
    } // The ESM 'does not export' case was already handled by core's symbol proapgation.
    // Look for an exports object if we bailed out.
    // TODO remove the first part of the condition once bundleGraph.resolveSymbol().identifier === null covers this


    if (res === undefined && mod.meta.isCommonJS || res === null) {
      if (wrappedAssets.has(mod.id)) {
        res = t().callExpression((0, _utils().getIdentifier)(mod, 'init'), []);
      } else {
        res = findSymbol(node, (0, _utils().assertString)(mod.meta.exportsIdentifier));

        if (!node) {
          return null;
        }
      }

      res = interop(mod, symbol, res, res);
      return res;
    }

    return res;
  }

  function findSymbol(node, symbol) {
    if (symbol && replacements.has(symbol)) {
      symbol = replacements.get(symbol);
    }

    let exp = symbol && exportedSymbols.get(symbol);

    if (exp) {
      symbol = exp[0].local;
    } // if the symbol exists there is no need to remap it


    if (symbol) {
      return t().identifier(symbol);
    }

    return null;
  }

  function interop(mod, originalName, originalNode, node) {
    // Handle interop for default imports of CommonJS modules.
    if (mod.meta.isCommonJS && originalName === 'default' && (0, _utils().needsDefaultInterop)(bundleGraph, bundle, mod)) {
      let name = (0, _utils().getName)(mod, '$interop$default');
      return t().identifier(name);
    } // if there is a CommonJS export return $id$exports.name


    if (originalName !== '*' && node != null) {
      if (t().isValidIdentifier(originalName, false)) {
        return t().memberExpression(node, t().identifier(originalName));
      } else {
        return t().memberExpression(node, t().stringLiteral(originalName), true);
      }
    }

    return node;
  }

  function addExternalModule(node, ancestors, dep) {
    // Find an existing import for this specifier, or create a new one.
    let importedFile = importedFiles.get(dep.moduleSpecifier);

    if (!importedFile) {
      var _dep$meta;

      importedFile = {
        source: dep.moduleSpecifier,
        specifiers: new Map(),
        isCommonJS: !!((_dep$meta = dep.meta) !== null && _dep$meta !== void 0 && _dep$meta.isCommonJS),
        loc: (0, _babelAstUtils().convertBabelLoc)(node.loc)
      };
      importedFiles.set(dep.moduleSpecifier, importedFile);
    }

    (0, _assert().default)(importedFile.specifiers != null);
    let specifiers = importedFile.specifiers; // For each of the imported symbols, add to the list of imported specifiers.

    for (let [imported, {
      local
    }] of dep.symbols) {
      // If already imported, just add the already renamed variable to the mapping.
      let renamed = specifiers.get(imported);

      if (renamed) {
        replacements.set(local, renamed);
        continue;
      }

      renamed = replacements.get(local); // If this symbol is re-exported, add it to the reexport list.

      let exp = exportedSymbols.get(local);

      if (exp) {
        renamed = exp[0].local;

        for (let e of exp) {
          reexports.add(e);
        }
      }

      if (!renamed) {
        // Rename the specifier to something nicer. Try to use the imported
        // name, except for default and namespace imports, and if the name is
        // already in scope.
        renamed = imported;

        if (imported === 'default' || imported === '*') {
          renamed = scope.generateUid(dep.moduleSpecifier);
        } else if (scope.has(imported)) {
          renamed = scope.generateUid(imported);
        } else {
          scope.add(imported);
        }

        replacements.set(local, renamed);
      }

      specifiers.set(imported, renamed);
    }

    return specifiers.get('*');
  }

  function addBundleImport(mod, node) {
    // Find a bundle that's reachable from the current bundle (sibling or ancestor)
    // containing this asset, and create an import for it if needed.
    let importedBundle = bundleGraph.findReachableBundleWithAsset(bundle, mod);

    if (!importedBundle) {
      throw new Error(`No reachable bundle found containing ${(0, _path().relative)(options.inputFS.cwd(), mod.filePath)}`);
    }

    let filePath = (0, _nullthrows().default)(importedBundle.filePath);
    let imported = importedFiles.get(filePath);

    if (!imported) {
      imported = {
        bundle: importedBundle,
        assets: new Set(),
        loc: (0, _babelAstUtils().convertBabelLoc)(node.loc)
      };
      importedFiles.set(filePath, imported);
    }

    (0, _assert().default)(imported.assets != null);
    imported.assets.add(mod);
    let initIdentifier = (0, _utils().getIdentifier)(mod, 'init');
    return t().callExpression(initIdentifier, []);
  }

  (0, _babylonWalk().traverse2)(ast, {
    CallExpression(node, state, ancestors) {
      let {
        arguments: args,
        callee
      } = node;

      if (!(0, t().isIdentifier)(callee)) {
        return;
      } // each require('module') call gets replaced with $parcel$require(id, 'module')


      if (callee.name === '$parcel$require') {
        let [id, source] = args;

        if (args.length < 2 || !(0, t().isStringLiteral)(id) || !(0, t().isStringLiteral)(source)) {
          throw new Error('invariant: invalid signature, expected : $parcel$require(number, string)');
        }

        let asset = (0, _nullthrows().default)(assets.get(id.value));
        let dep = (0, _nullthrows().default)(bundleGraph.getDependencies(asset).find(dep => dep.moduleSpecifier === source.value));
        let asyncResolution = bundleGraph.resolveAsyncDependency(dep, bundle);
        let mod = (asyncResolution === null || asyncResolution === void 0 ? void 0 : asyncResolution.type) === 'asset' ? // Prefer the underlying asset over a runtime to load it. It will
        // be wrapped in Promise.resolve() later.
        asyncResolution.value : bundleGraph.getDependencyResolution(dep, bundle);
        let newNode;

        if (!bundleGraph.isDependencySkipped(dep)) {
          if (!mod) {
            if (dep.isOptional) {
              newNode = THROW_TEMPLATE({
                MODULE: t().stringLiteral(source.value)
              });
              scope.add('$parcel$missingModule');
            } else {
              let name = addExternalModule(node, ancestors, dep);

              if (!isUnusedValue(ancestors) && name) {
                newNode = t().identifier(name);
              }
            }
          } else {
            // If there is a third arg, it is an identifier to replace the require with.
            // This happens when `require('foo').bar` is detected in the hoister.
            if (args.length > 2 && (0, t().isIdentifier)(args[2])) {
              newNode = maybeReplaceIdentifier(args[2]);
            } else {
              if (mod.meta.id && assets.has((0, _utils().assertString)(mod.meta.id))) {
                let isValueUsed = !isUnusedValue(ancestors); // We need to wrap the module in a function when a require
                // call happens inside a non top-level scope, e.g. in a
                // function, if statement, or conditional expression.

                if (wrappedAssets.has(mod.id)) {
                  newNode = t().callExpression((0, _utils().getIdentifier)(mod, 'init'), []);
                } // Replace with nothing if the require call's result is not used.
                else if (isValueUsed) {
                    newNode = t().identifier((0, _utils().assertString)(mod.meta.exportsIdentifier));
                  }
              } else if (mod.type === 'js') {
                newNode = addBundleImport(mod, node);
              }
            } // async dependency that was internalized


            if (newNode && (asyncResolution === null || asyncResolution === void 0 ? void 0 : asyncResolution.type) === 'asset' && !(0, t().isExpressionStatement)(newNode)) {
              let _newNode = newNode; // For Flow

              newNode = t().callExpression(t().memberExpression(t().identifier('Promise'), t().identifier('resolve')), [_newNode]);
            }
          }
        }

        if (newNode) {
          return newNode;
        } else {
          if (isUnusedValue(ancestors)) {
            return _babylonWalk().REMOVE;
          } else {
            // e.g. $parcel$exportWildcard;
            return t().objectExpression([]);
          }
        }
      } else if (callee.name === '$parcel$require$resolve') {
        let [id, source] = args;

        if (args.length !== 2 || !(0, t().isStringLiteral)(id) || !(0, t().isStringLiteral)(source)) {
          throw new Error('invariant: invalid signature, expected : $parcel$require$resolve(number, string)');
        }

        let mapped = (0, _nullthrows().default)(assets.get(id.value));
        let dep = (0, _nullthrows().default)(bundleGraph.getDependencies(mapped).find(dep => dep.moduleSpecifier === source.value));

        if (!bundleGraph.getDependencyResolution(dep, bundle)) {
          // was excluded from bundling (e.g. includeNodeModules = false)
          if (bundle.env.outputFormat !== 'commonjs') {
            throw (0, _utils().getThrowableDiagnosticForNode)("'require.resolve' calls for excluded assets are only supported with outputFormat: 'commonjs'", mapped.filePath, (0, _babelAstUtils().convertBabelLoc)(node.loc));
          }

          return REQUIRE_RESOLVE_CALL_TEMPLATE({
            ID: t().stringLiteral(source.value)
          });
        } else {
          throw (0, _utils().getThrowableDiagnosticForNode)("'require.resolve' calls for bundled modules or bundled assets aren't supported with scope hoisting", mapped.filePath, (0, _babelAstUtils().convertBabelLoc)(node.loc));
        }
      } else if (callee.name === '$parcel$exportWildcard') {
        if (args.length !== 2 || !(0, t().isIdentifier)(args[0])) {
          throw new Error('Invalid call to $parcel$exportWildcard');
        }

        if (!needsExportsIdentifier(args[0].name)) {
          return _babylonWalk().REMOVE;
        }
      } else if (callee.name === '$parcel$export') {
        let [obj, symbol] = args;
        (0, _assert().default)((0, t().isIdentifier)(obj));
        (0, _assert().default)((0, t().isStringLiteral)(symbol));
        let objName = obj.name;
        let symbolName = symbol.value; // Remove if the $id$exports object is unused.

        if (!needsExportsIdentifier(objName)) {
          return _babylonWalk().REMOVE;
        }

        if (objName === 'exports') {
          // Assignment inside a wrapped asset
          return;
        }

        let asset = (0, _nullthrows().default)(exportsMap.get(objName));
        let incomingDeps = bundleGraph.getIncomingDependencies(asset);
        let unused = incomingDeps.every(d => {
          let symbols = bundleGraph.getUsedSymbols(d);
          return !symbols.has(symbolName) && !symbols.has('*');
        });

        if (unused) {
          return _babylonWalk().REMOVE;
        }
      }
    },

    VariableDeclarator: {
      exit(node) {
        let {
          id
        } = node;

        if ((0, t().isIdentifier)(id)) {
          if (!needsExportsIdentifier(id.name)) {
            return _babylonWalk().REMOVE;
          }

          if (!needsDeclaration(id.name)) {
            return _babylonWalk().REMOVE;
          }
        }
      }

    },
    VariableDeclaration: {
      exit(node) {
        if (node.declarations.length === 0) {
          return _babylonWalk().REMOVE;
        } // Handle exported declarations using output format specific logic.


        let exported = [];

        for (let decl of node.declarations) {
          let bindingIdentifiers = t().getBindingIdentifiers(decl.id);

          for (let name in bindingIdentifiers) {
            let exp = exportedSymbols.get(name);

            if (exp) {
              bindingIdentifiers[name].name = exp[0].local;
              exported.push(...exp);
            }
          }
        }

        if (exported.length > 0) {
          return format.generateMainExport(node, exported);
        }
      }

    },
    Declaration: {
      exit(node) {
        if (t().isVariableDeclaration(node)) {
          return;
        }

        if (node.id != null && (0, t().isIdentifier)(node.id)) {
          let id = node.id;

          if (!needsDeclaration(id.name)) {
            return _babylonWalk().REMOVE;
          } // Handle exported declarations using output format specific logic.


          let exp = exportedSymbols.get(id.name);

          if (exp) {
            id.name = exp[0].local;
            return format.generateMainExport(node, exp);
          }
        }
      }

    },

    AssignmentExpression(node) {
      let {
        left,
        right
      } = node;

      if ((0, t().isMemberExpression)(left)) {
        let {
          object,
          property,
          computed
        } = left;

        if (!((0, t().isIdentifier)(object) && ((0, t().isIdentifier)(property) && !computed || (0, t().isStringLiteral)(property)))) {
          return;
        } // Rename references to exported symbols to the exported name.


        let exp = exportedSymbols.get(object.name);

        if (exp) {
          object.name = exp[0].local;
        }

        let asset = exportsMap.get(object.name);

        if (!asset) {
          return;
        }

        if (!needsExportsIdentifier(object.name)) {
          return _babylonWalk().REMOVE;
        }

        if ((0, t().isIdentifier)(right) && !needsDeclaration(right.name)) {
          return _babylonWalk().REMOVE;
        }
      }

      if ((0, t().isIdentifier)(node.left)) {
        let res = maybeReplaceIdentifier(node.left);

        if ((0, t().isIdentifier)(res) || (0, t().isMemberExpression)(res)) {
          node.left = res;
        } // remove unused CommonJS `$id$export$foo = $id$var$foo;`


        if ((0, t().isIdentifier)(left) && !needsDeclaration(left.name)) {
          return _babylonWalk().REMOVE;
        }
      }
    },

    Identifier(node, state, ancestors) {
      if (t().isReferenced(node, ancestors[ancestors.length - 2], ancestors[ancestors.length - 3])) {
        // If referencing a helper, add it to the scope.
        if (helpers.has(node.name)) {
          scope.add(node.name);
          return;
        } // Rename references to exported symbols to the exported name.


        let exp = exportedSymbols.get(node.name);

        if (exp) {
          node.name = exp[0].local;
        }

        return maybeReplaceIdentifier(node);
      }
    },

    ExpressionStatement: {
      exit(node) {
        // Handle exported declarations using output format specific logic.
        if ((0, t().isAssignmentExpression)(node.expression) && (0, t().isIdentifier)(node.expression.left)) {
          let left = node.expression.left;
          let exp = exportedSymbols.get(left.name);

          if (exp) {
            left.name = exp[0].local;
            return format.generateMainExport(node, exp);
          }
        }
      }

    },
    SequenceExpression: {
      exit(node) {
        // This can happen if a $parcel$require result is unused.
        if (node.expressions.length === 1) {
          return node.expressions[0];
        }
      }

    },
    Program: {
      exit(node) {
        let statements = node.body;
        let hoistedImports = [];

        for (let file of importedFiles.values()) {
          if (file.bundle) {
            let {
              hoisted,
              imports
            } = format.generateBundleImports(bundleGraph, bundle, file, scope);
            statements = imports.concat(statements);
            hoistedImports = hoistedImports.concat(hoisted);
          } else {
            let res = format.generateExternalImport(bundle, file, scope);
            statements = res.concat(statements);
          }
        }

        if (referencedAssets.size > 0) {
          // Insert fake init functions that will be imported in other bundles,
          // because `asset.meta.shouldWrap` isn't set in a packager if `asset` is
          // not in the current bundle.
          statements = statements.concat([...referencedAssets].filter(a => !wrappedAssets.has(a.id)).map(a => {
            return FAKE_INIT_TEMPLATE({
              INIT: (0, _utils().getIdentifier)(a, 'init'),
              EXPORTS: t().identifier((0, _utils().assertString)(a.meta.exportsIdentifier))
            });
          }));
        } // Generate exports


        let exported = format.generateBundleExports(bundleGraph, bundle, referencedAssets, scope, reexports);
        statements = statements.concat(exported); // If the prelude is needed, ensure parcelRequire is available.

        if (!scope.names.has('parcelRequire') && (0, _utils().needsPrelude)(bundle, bundleGraph)) {
          scope.add('parcelRequire');
        }

        if (bundle.env.outputFormat === 'global') {
          // Wrap async bundles in a closure and register with parcelRequire so they are executed
          // at the right time (after other bundle dependencies are loaded).
          let isAsync = !(0, _utils().isEntry)(bundle, bundleGraph);

          if (isAsync) {
            statements = REGISTER_TEMPLATE({
              STATEMENTS: statements,
              REFERENCED_IDS: t().arrayExpression([bundle.getMainEntry(), ...referencedAssets].filter(Boolean).map(asset => t().stringLiteral(bundleGraph.getAssetPublicId(asset)))),
              PARCEL_REQUIRE: t().identifier(parcelRequireName)
            });
          }

          if ((0, _utils().needsPrelude)(bundle, bundleGraph)) {
            scope.add('$parcel$global');
            statements = [PARCEL_REQUIRE_NAME_TEMPLATE({
              PARCEL_REQUIRE_NAME: t().stringLiteral(parcelRequireName)
            })].concat(PRELUDE).concat(statements);
          }
        }

        let usedHelpers = [];

        for (let [name, helper] of helpers) {
          if (scope.names.has(name)) {
            usedHelpers.push(helper);
          }
        }

        if (scope.names.has('parcelRequire')) {
          usedHelpers.push(PARCEL_REQUIRE_TEMPLATE({
            PARCEL_REQUIRE_NAME: t().identifier(parcelRequireName)
          }));
        }

        statements = hoistedImports.concat(usedHelpers).concat(statements);

        if (bundle.env.outputFormat === 'global') {
          statements = [WRAPPER_TEMPLATE({
            STATEMENTS: statements
          })];
        } // $FlowFixMe


        return t().program(statements);
      }

    }
  });
  return ast;
}

function isUnusedValue(ancestors, i = 1) {
  let node = ancestors[ancestors.length - i];
  let parent = ancestors[ancestors.length - i - 1];
  return (0, t().isExpressionStatement)(parent) || (0, t().isSequenceExpression)(parent) && (node !== parent.expressions[parent.expressions.length - 1] || isUnusedValue(ancestors, i + 1));
}