"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _plugin() {
  const data = require("@parcel/plugin");

  _plugin = function () {
    return data;
  };

  return data;
}

function _fileSystemLoader() {
  const data = _interopRequireDefault(require("css-modules-loader-core/lib/file-system-loader"));

  _fileSystemLoader = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _postcssValueParser() {
  const data = _interopRequireDefault(require("postcss-value-parser"));

  _postcssValueParser = function () {
    return data;
  };

  return data;
}

function _postcss() {
  const data = _interopRequireDefault(require("postcss"));

  _postcss = function () {
    return data;
  };

  return data;
}

function _postcssModules() {
  const data = _interopRequireDefault(require("postcss-modules"));

  _postcssModules = function () {
    return data;
  };

  return data;
}

function _loadConfig() {
  const data = require("./loadConfig");

  _loadConfig = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const COMPOSES_RE = /composes:.+from\s*("|').*("|')\s*;?/;
const FROM_IMPORT_RE = /.+from\s*(?:"|')(.*)(?:"|')\s*;?/;

var _default = new (_plugin().Transformer)({
  loadConfig({
    config,
    options,
    logger
  }) {
    return (0, _loadConfig().load)({
      config,
      options,
      logger
    });
  },

  canReuseAST({
    ast
  }) {
    return ast.type === 'postcss' && _semver().default.satisfies(ast.version, '^8.2.1');
  },

  async parse({
    asset,
    config
  }) {
    if (!config) {
      return;
    }

    return {
      type: 'postcss',
      version: '8.2.1',
      program: _postcss().default.parse(await asset.getCode(), {
        from: asset.filePath
      }).toJSON()
    };
  },

  async transform({
    asset,
    config,
    options,
    resolve
  }) {
    asset.type = 'css';

    if (!config) {
      return [asset];
    }

    let plugins = [...config.hydrated.plugins];
    let cssModules = null;

    if (config.hydrated.modules) {
      plugins.push((0, _postcssModules().default)({
        getJSON: (filename, json) => cssModules = json,
        Loader: createLoader(asset, resolve),
        generateScopedName: (name, filename) => `_${name}_${(0, _utils().md5FromString)(_path().default.relative(options.projectRoot, filename)).substr(0, 6)}`,
        ...config.hydrated.modules
      }));
    }

    let ast = (0, _nullthrows().default)(await asset.getAST());

    let program = _postcss().default.fromJSON(ast.program);

    let code = asset.isASTDirty() ? null : await asset.getCode();

    if (code == null || COMPOSES_RE.test(code)) {
      program.walkDecls(decl => {
        let [, importPath] = FROM_IMPORT_RE.exec(decl.value) || [];

        if (decl.prop === 'composes' && importPath != null) {
          let parsed = (0, _postcssValueParser().default)(decl.value);
          parsed.walk(node => {
            if (node.type === 'string') {
              asset.addDependency({
                moduleSpecifier: importPath,
                loc: {
                  filePath: asset.filePath,
                  start: decl.source.start,
                  end: {
                    line: decl.source.start.line,
                    column: decl.source.start.column + importPath.length
                  }
                }
              });
            }
          });
        }
      });
    } // $FlowFixMe Added in Flow 0.121.0 upgrade in #4381


    let {
      messages,
      root
    } = await (0, _postcss().default)(plugins).process(program, config.hydrated);
    asset.setAST({
      type: 'postcss',
      version: '8.2.1',
      program: root.toJSON()
    });

    for (let msg of messages) {
      if (msg.type === 'dependency') {
        asset.addIncludedFile(msg.file);
      }
    }

    let assets = [asset];

    if (cssModules) {
      // $FlowFixMe
      let cssModulesList = Object.entries(cssModules);
      let deps = asset.getDependencies().filter(dep => !dep.isURL);
      let code;

      if (deps.length > 0) {
        code = `
          module.exports = Object.assign({}, ${deps.map(dep => `require(${JSON.stringify(dep.moduleSpecifier)})`).join(', ')}, ${JSON.stringify(cssModules, null, 2)});
        `;
      } else {
        code = cssModulesList.map( // This syntax enables shaking the invidual statements, so that unused classes don't even exist in JS.
        ([className, classNameHashed]) => `module.exports[${JSON.stringify(className)}] = ${JSON.stringify(classNameHashed)};`).join('\n');
      }

      asset.symbols.ensure();

      for (let [k, v] of cssModulesList) {
        asset.symbols.set(k, v);
      }

      asset.symbols.set('default', 'default');
      assets.push({
        type: 'js',
        filePath: asset.filePath + '.js',
        content: code
      });
    }

    return assets;
  },

  generate({
    ast
  }) {
    let code = '';

    _postcss().default.stringify(_postcss().default.fromJSON(ast.program), c => {
      code += c;
    });

    return {
      content: code
    };
  }

});

exports.default = _default;

function createLoader(asset, resolve) {
  return class extends _fileSystemLoader().default {
    async fetch(composesPath, relativeTo) {
      let importPath = composesPath.replace(/^["']|["']$/g, '');
      let resolved = await resolve(relativeTo, importPath);

      let rootRelativePath = _path().default.resolve(_path().default.dirname(relativeTo), resolved);

      let root = _path().default.resolve('/'); // fixes an issue on windows which is part of the css-modules-loader-core
      // see https://github.com/css-modules/css-modules-loader-core/issues/230


      if (rootRelativePath.startsWith(root)) {
        rootRelativePath = rootRelativePath.substr(root.length);
      }

      let source = await asset.fs.readFile(resolved, 'utf-8');
      let {
        exportTokens
      } = await this.core.load(source, rootRelativePath, undefined, this.fetch.bind(this));
      return exportTokens;
    }

    get finalSource() {
      return '';
    }

  };
}