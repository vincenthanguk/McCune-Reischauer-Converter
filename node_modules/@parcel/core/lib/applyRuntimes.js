"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = applyRuntimes;

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _AssetGraph() {
  const data = _interopRequireWildcard(require("./AssetGraph"));

  _AssetGraph = function () {
    return data;
  };

  return data;
}

function _BundleGraph() {
  const data = _interopRequireDefault(require("./public/BundleGraph"));

  _BundleGraph = function () {
    return data;
  };

  return data;
}

function _BundleGraph2() {
  const data = _interopRequireDefault(require("./BundleGraph"));

  _BundleGraph2 = function () {
    return data;
  };

  return data;
}

function _Bundle() {
  const data = require("./public/Bundle");

  _Bundle = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@parcel/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = _interopRequireWildcard(require("@parcel/diagnostic"));

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _Dependency() {
  const data = require("./public/Dependency");

  _Dependency = function () {
    return data;
  };

  return data;
}

function _AssetGraphRequest() {
  const data = _interopRequireDefault(require("./requests/AssetGraphRequest"));

  _AssetGraphRequest = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function applyRuntimes({
  bundleGraph,
  config,
  options,
  pluginOptions,
  requestTracker,
  optionsRef
}) {
  let connections = [];

  for (let bundle of bundleGraph.getBundles()) {
    let runtimes = await config.getRuntimes(bundle.env.context);

    for (let runtime of runtimes) {
      try {
        let applied = await runtime.plugin.apply({
          bundle: _Bundle().NamedBundle.get(bundle, bundleGraph, options),
          bundleGraph: new (_BundleGraph().default)(bundleGraph, _Bundle().NamedBundle.get, options),
          options: pluginOptions,
          logger: new (_logger().PluginLogger)({
            origin: runtime.name
          })
        });

        if (applied) {
          let runtimeAssets = Array.isArray(applied) ? applied : [applied];

          for (let {
            code,
            dependency,
            filePath,
            isEntry
          } of runtimeAssets) {
            let assetGroup = {
              code,
              filePath,
              env: bundle.env,
              // Runtime assets should be considered source, as they should be
              // e.g. compiled to run in the target environment
              isSource: true
            };
            connections.push({
              bundle,
              assetGroup,
              dependency: dependency,
              isEntry
            });
          }
        }
      } catch (e) {
        throw new (_diagnostic().default)({
          diagnostic: (0, _diagnostic().errorToDiagnostic)(e, {
            origin: runtime.name,
            filePath: bundle.filePath
          })
        });
      }
    }
  }

  let runtimesAssetGraph = await reconcileNewRuntimes(requestTracker, connections, optionsRef);

  let runtimesGraph = _BundleGraph2().default.fromAssetGraph(runtimesAssetGraph, bundleGraph._publicIdByAssetId, bundleGraph._assetPublicIds); // Merge the runtimes graph into the main bundle graph.


  bundleGraph.merge(runtimesGraph);

  for (let [assetId, publicId] of runtimesGraph._publicIdByAssetId) {
    bundleGraph._publicIdByAssetId.set(assetId, publicId);

    bundleGraph._assetPublicIds.add(publicId);
  }

  for (let {
    bundle,
    assetGroup,
    dependency,
    isEntry
  } of connections) {
    let assetGroupNode = (0, _AssetGraph().nodeFromAssetGroup)(assetGroup);
    let assetGroupAssets = runtimesAssetGraph.getNodesConnectedFrom(assetGroupNode);
    (0, _assert().default)(assetGroupAssets.length === 1);
    let runtimeNode = assetGroupAssets[0];
    (0, _assert().default)(runtimeNode.type === 'asset');
    let resolution = dependency && bundleGraph.getDependencyResolution((0, _Dependency().dependencyToInternalDependency)(dependency), bundle);
    let duplicatedAssetIds = new Set();

    runtimesGraph._graph.traverse((node, _, actions) => {
      if (node.type !== 'dependency') {
        return;
      }

      let assets = runtimesGraph._graph.getNodesConnectedFrom(node).map(assetNode => {
        (0, _assert().default)(assetNode.type === 'asset');
        return assetNode.value;
      });

      for (let asset of assets) {
        if (bundleGraph.isAssetReachableFromBundle(asset, bundle) || (resolution === null || resolution === void 0 ? void 0 : resolution.id) === asset.id) {
          duplicatedAssetIds.add(asset.id);
          actions.skipChildren();
        }
      }
    }, runtimeNode);

    runtimesGraph._graph.traverse((node, _, actions) => {
      if (node.type === 'asset' || node.type === 'dependency') {
        if (duplicatedAssetIds.has(node.id)) {
          actions.skipChildren();
          return;
        }

        bundleGraph._graph.addEdge(bundle.id, node.id, 'contains');
      }
    }, runtimeNode);

    if (isEntry) {
      bundleGraph._graph.addEdge((0, _nullthrows().default)(bundleGraph._graph.getNode(bundle.id)).id, runtimeNode.id);

      bundle.entryAssetIds.unshift(runtimeNode.id);
    }

    if (dependency == null) {
      // Verify this asset won't become an island
      (0, _assert().default)(bundleGraph._graph.getNodesConnectedTo(runtimeNode).length > 0, 'Runtime must have an inbound dependency or be an entry');
    } else {
      bundleGraph._graph.addEdge(dependency.id, runtimeNode.id);
    }
  }
}

async function reconcileNewRuntimes(requestTracker, connections, optionsRef) {
  let assetGroups = connections.map(t => t.assetGroup);
  let request = (0, _AssetGraphRequest().default)({
    name: 'Runtimes',
    assetGroups,
    optionsRef
  }); // rebuild the graph

  return (await requestTracker.runRequest(request, {
    force: true
  })).assetGraph;
}