"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.esm2cjs = esm2cjs;

function _types() {
  const data = require("@parcel/types");

  _types = function () {
    return data;
  };

  return data;
}

function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function () {
    return data;
  };

  return data;
}

function _babylonWalk() {
  const data = require("@parcel/babylon-walk");

  _babylonWalk = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let modulesVisitor = {
  Identifier(node, state, ancestors) {
    let parent = ancestors[ancestors.length - 2];

    if (!t().isReferenced(node, parent, ancestors[ancestors.length - 3])) {
      return;
    }

    let {
      scope
    } = state;
    return () => {
      let binding = scope.getBinding(node.name);

      if (!binding || !(0, t().isImportDeclaration)(binding)) {
        return;
      }

      let specifier = binding.specifiers.find(specifier => specifier.local.name === node.name);

      if ((0, t().isImportSpecifier)(specifier)) {
        return getSpecifier(state, binding.source, specifier.imported.name);
      } else if ((0, t().isImportNamespaceSpecifier)(specifier)) {
        return getNamespace(state, binding.source);
      } else if ((0, t().isImportDefaultSpecifier)(specifier)) {
        return getDefault(state, binding.source);
      }
    };
  },

  ImportDeclaration: {
    exit(node, {
      imports
    }) {
      imports.push(node);
      return _babylonWalk().REMOVE;
    }

  },
  ExportNamedDeclaration: {
    exit(node, state) {
      let {
        exports,
        imports
      } = state;
      let {
        declaration,
        source,
        specifiers
      } = node;
      state.needsInteropFlag = true;

      if (source) {
        imports.push(node);
        return () => {
          for (let specifier of specifiers) {
            let local;

            if ((0, t().isExportNamespaceSpecifier)(specifier)) {
              local = getNamespace(state, source);
            } else if ((0, t().isExportDefaultSpecifier)(specifier)) {
              local = getDefault(state, source);
            } else if ((0, t().isExportSpecifier)(specifier)) {
              local = specifier.local.name === 'default' ? getDefault(state, source) : getSpecifier(state, source, specifier.local.name);
            } else {
              throw new Error('Unknown specifier type: ' + specifier.type);
            }

            exports.push({
              exported: specifier.exported,
              local
            });
          }

          return _babylonWalk().REMOVE;
        };
      } else if (declaration) {
        if ((0, t().isFunctionDeclaration)(declaration) && (0, t().isIdentifier)(declaration.id)) {
          let name = declaration.id.name;
          exports.push({
            local: t().identifier(name),
            exported: t().identifier(name)
          });
        } else {
          // Find all binding identifiers, and insert assignments to `exports`
          let identifiers = t().getBindingIdentifiers(declaration);

          for (let id of Object.keys(identifiers)) {
            exports.push({
              local: t().identifier(id),
              exported: t().identifier(id)
            });
          }
        }

        return declaration;
      } else if (specifiers.length > 0) {
        // This must happen AFTER the Identifier visitor above replaces the specifiers
        // in the case of import foo from 'foo'; export {foo};
        return () => {
          // Add assignments to `exports` for each specifier
          for (let specifier of specifiers) {
            (0, _assert().default)(specifier.type === 'ExportSpecifier');
            exports.push({
              local: specifier.local,
              exported: specifier.exported
            });
          }

          return _babylonWalk().REMOVE;
        };
      }

      return _babylonWalk().REMOVE;
    }

  },

  ExportAllDeclaration(node, state) {
    state.imports.push(node);
    state.needsInteropFlag = true;
    return _babylonWalk().REMOVE;
  },

  ExportDefaultDeclaration: {
    exit(node, state) {
      // This has to happen AFTER any referenced identifiers are replaced.
      return () => {
        let {
          declaration
        } = node;
        state.needsInteropFlag = true; // If the declaration has a name, insert an assignment to `exports` afterward.

        if (declaration.id != null && (0, t().isIdentifier)(declaration.id)) {
          let id = t().identifier(declaration.id.name);
          state.scope.addReference(id);
          return [declaration, t().expressionStatement(t().assignmentExpression('=', t().memberExpression(t().identifier('exports'), t().identifier('default')), id))];
        } else if (declaration.type !== 'TSDeclareFunction') {
          // Replace with an assignment to `exports`.
          return t().expressionStatement(t().assignmentExpression('=', t().memberExpression(t().identifier('exports'), t().identifier('default')), t().toExpression(declaration)));
        } else {
          return _babylonWalk().REMOVE;
        }
      };
    }

  },

  ThisExpression(node, {
    scope
  }, ancestors) {
    let s = scope;

    while (s) {
      if (s.type === 'function') {
        return;
      }

      s = s.parent;
    }

    if (ancestors.some(a => t().isClassBody(a))) {
      return;
    }

    return t().identifier('undefined');
  }

};

function getNames(state, source) {
  let names = state.importNames.get(source.value);

  if (!names) {
    let name = state.scope.generateUid(source.value);
    names = {
      name,
      namespace: '',
      default: ''
    };
    state.importNames.set(source.value, names);
  }

  return names;
}

function getSpecifier(state, source, name) {
  let names = getNames(state, source);
  return t().memberExpression(t().identifier(names.name), t().identifier(name));
}

function getDefault(state, source) {
  let names = getNames(state, source);

  if (!names.default) {
    names.default = state.scope.generateUid(names.name + 'Default');
  }

  return t().memberExpression(t().identifier(names.default), t().identifier('default'));
}

function getNamespace(state, source) {
  // Interop between import namespace declarations and CJS is very inconsistent.
  // Node always returns {default: module.exports}.
  // Babel does the same for functions and primative values, but for objects returns
  // {...module.exports, default: module.exports}.
  // Parcel currently just returns the original module.exports in scope hoisting.
  // Doing the same here to match for now, but we should revisit this.
  let names = getNames(state, source); // if (!names.namespace) {
  //   names.namespace = state.scope.generateUid(names.name + 'Namespace');
  // }

  return t().identifier(names.name);
}

const visitor = (0, _babylonWalk().mergeVisitors)(_babylonWalk().scopeVisitor, modulesVisitor);

function esm2cjs(ast, asset) {
  let imports = [];
  let importNames = new Map();
  let scope = new (_babylonWalk().Scope)('program');
  let exports = [];
  let state = {
    imports,
    importNames,
    exports,
    needsInteropFlag: false,
    scope
  };
  (0, _babylonWalk().traverse2)(ast, visitor, state);
  let body = ast.program.body;
  let prepend = [];
  let helpersId;

  let addHelpers = () => {
    if (helpersId) {
      return helpersId;
    } // Add a dependency so Parcel includes the helpers


    let moduleRoot = _path().default.resolve(__dirname, '..', '..');

    let helpersPath = _path().default.resolve(__dirname, '..', 'esmodule-helpers.js');

    let helperSpecifier = `@parcel/transformer-js/${(0, _utils().normalizeSeparators)(_path().default.relative(moduleRoot, helpersPath))}`;
    asset === null || asset === void 0 ? void 0 : asset.addDependency({
      moduleSpecifier: helperSpecifier,
      resolveFrom: __filename,
      env: {
        includeNodeModules: {
          '@parcel/transformer-js': true
        }
      }
    });
    helpersId = scope.generateUid('parcelHelpers');
    prepend.push(t().variableDeclaration('var', [t().variableDeclarator(t().identifier(helpersId), t().callExpression(t().identifier('require'), [t().stringLiteral(helperSpecifier)]))]));
    return helpersId;
  };

  if (state.needsInteropFlag) {
    prepend.push(t().expressionStatement(t().callExpression(t().memberExpression(t().identifier(addHelpers()), t().identifier('defineInteropFlag')), [t().identifier('exports')])));
  }

  for (let {
    local,
    exported
  } of exports) {
    prepend.push(t().expressionStatement(t().callExpression(t().memberExpression(t().identifier(addHelpers()), t().identifier('export')), [t().identifier('exports'), t().stringLiteral(exported.name), t().functionExpression(null, [], t().blockStatement([t().returnStatement(local)]))])));
  }

  for (let imp of imports) {
    (0, _assert().default)(imp.source != null);
    let source = imp.source; // If the result of the import is unused, simply insert a require call.

    if (!state.importNames.has(source.value) && !(0, t().isExportAllDeclaration)(imp)) {
      prepend.push(t().expressionStatement(t().callExpression(t().identifier('require'), [source])));
      continue;
    }

    let names = getNames(state, source);

    if (!scope.bindings.has(names.name)) {
      let decl = t().variableDeclaration('var', [t().variableDeclarator(t().identifier(names.name), t().callExpression(t().identifier('require'), [source]))]);
      prepend.push(decl);
      scope.addBinding(names.name, decl, 'var');
    }

    if ((0, t().isExportAllDeclaration)(imp)) {
      prepend.push(t().expressionStatement(t().callExpression(t().memberExpression(t().identifier(addHelpers()), t().identifier('exportAll')), [t().identifier(names.name), t().identifier('exports')])));
    }

    if (names.default) {
      prepend.push(t().variableDeclaration('var', [t().variableDeclarator(t().identifier(names.default), t().callExpression(t().memberExpression(t().identifier(addHelpers()), t().identifier('interopDefault')), [t().identifier(names.name)]))]));
    } // if (names.namespace) {
    //   prepend.push(
    //     t.variableDeclaration('var', [
    //       t.variableDeclarator(
    //         t.identifier(names.namespace),
    //         t.callExpression(
    //           t.memberExpression(
    //             t.identifier(addHelpers()),
    //             t.identifier('namespace'),
    //           ),
    //           [t.identifier(names.name)],
    //         ),
    //       ),
    //     ]),
    //   );
    // }

  }

  body.unshift(...prepend);
}