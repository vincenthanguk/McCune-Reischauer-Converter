"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _template() {
  const data = _interopRequireDefault(require("@babel/template"));

  _template = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _plugin() {
  const data = require("@parcel/plugin");

  _plugin = function () {
    return data;
  };

  return data;
}

function _dependencies() {
  const data = _interopRequireDefault(require("./visitors/dependencies"));

  _dependencies = function () {
    return data;
  };

  return data;
}

function _process() {
  const data = _interopRequireDefault(require("./visitors/process"));

  _process = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("./visitors/fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _globals() {
  const data = _interopRequireDefault(require("./visitors/globals"));

  _globals = function () {
    return data;
  };

  return data;
}

function _traverse() {
  const data = _interopRequireDefault(require("@babel/traverse"));

  _traverse = function () {
    return data;
  };

  return data;
}

function _babylonWalk() {
  const data = require("@parcel/babylon-walk");

  _babylonWalk = function () {
    return data;
  };

  return data;
}

function _scopeHoisting() {
  const data = require("@parcel/scope-hoisting");

  _scopeHoisting = function () {
    return data;
  };

  return data;
}

function _babelAstUtils() {
  const data = require("@parcel/babel-ast-utils");

  _babelAstUtils = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = require("@parcel/diagnostic");

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _modules() {
  const data = require("./visitors/modules");

  _modules = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CONFIG_SCHEMA = {
  type: 'object',
  properties: {
    inlineFS: {
      type: 'boolean'
    },
    inlineEnvironment: {
      oneOf: [{
        type: 'boolean'
      }, {
        type: 'array',
        items: {
          type: 'string'
        }
      }]
    }
  },
  additionalProperties: false
};
const IMPORT_RE = /\b(?:import\b|export\b|require\s*\()/;
const ENV_RE = /\b(?:process\.env)\b/;
const BROWSER_RE = /\b(?:process\.browser)\b/;
const GLOBAL_RE = /\b(?:process|__dirname|__filename|global|Buffer|define)\b/;
const FS_RE = /\breadFileSync\b/;
const SW_RE = /\bnavigator\s*\.\s*serviceWorker\s*\.\s*register\s*\(/;
const WORKER_RE = /\bnew\s*(?:Shared)?Worker\s*\(/;

function canHaveDependencies(code) {
  return IMPORT_RE.test(code) || GLOBAL_RE.test(code) || SW_RE.test(code) || WORKER_RE.test(code);
}

var _default = new (_plugin().Transformer)({
  async loadConfig({
    options,
    config
  }) {
    let result = await config.getConfig([], {
      packageKey: '@parcel/transformer-js'
    });

    if (result) {
      _utils().validateSchema.diagnostic(CONFIG_SCHEMA, {
        data: result.contents,
        // FIXME
        source: await options.inputFS.readFile(result.filePath, 'utf8'),
        filePath: result.filePath,
        prependKey: `/${(0, _diagnostic().encodeJSONKeyComponent)('@parcel/transformer-js')}`
      }, // FIXME
      '@parcel/transformer-js', 'Invalid config for @parcel/transformer-js');
    } // Check if we should ignore fs calls
    // See https://github.com/defunctzombie/node-browser-resolve#skip


    let pkg = await config.getPackage();
    let ignoreFS = pkg && pkg.browser && typeof pkg.browser === 'object' && pkg.browser.fs === false;
    config.setResult({ ...(result === null || result === void 0 ? void 0 : result.contents),
      ignoreFS
    });
  },

  canReuseAST({
    ast
  }) {
    return ast.type === 'babel' && _semver().default.satisfies(ast.version, '^7.0.0');
  },

  async parse({
    asset,
    options
  }) {
    let code = await asset.getCode();

    if (!asset.env.shouldScopeHoist && !canHaveDependencies(code) && !ENV_RE.test(code) && !BROWSER_RE.test(code) && !FS_RE.test(code)) {
      return null;
    }

    return (0, _babelAstUtils().parse)({
      asset,
      code,
      options
    });
  },

  async transform({
    asset,
    config,
    options,
    logger
  }) {
    // When this asset is an bundle entry, allow that bundle to be split to load shared assets separately.
    // Only set here if it is null to allow previous transformers to override this behavior.
    if (asset.isSplittable == null) {
      asset.isSplittable = true;
    }

    asset.type = 'js';
    let ast = await asset.getAST();

    if (!ast) {
      return [asset];
    }

    let {
      inlineEnvironment = true,
      inlineFS = true,
      ignoreFS
    } = config || {};
    let code = asset.isASTDirty() ? null : await asset.getCode(); // Inline process/environment variables

    if (!asset.env.isNode() && (code == null || ENV_RE.test(code)) || asset.env.isBrowser() && (code == null || BROWSER_RE.test(code))) {
      (0, _babylonWalk().ancestor)(ast.program, _process().default, {
        asset,
        ast,
        env: options.env,
        isNode: asset.env.isNode(),
        replaceEnv: inlineEnvironment,
        isBrowser: asset.env.isBrowser()
      });
    }

    let isASTDirty;

    if (!asset.env.isNode()) {
      // Inline fs calls, run before globals to also collect Buffer
      if (code == null || FS_RE.test(code)) {
        if (!ignoreFS) {
          _traverse().default.cache.clearScope();

          (0, _traverse().default)(ast.program, _fs().default, null, {
            asset,
            logger,
            ast,
            options,
            inlineFS
          });
        }
      } // Insert node globals


      if (code == null || GLOBAL_RE.test(code)) {
        let globals = new Map();
        (0, _babylonWalk().ancestor)(ast.program, _globals().default, {
          asset,
          globals
        });

        if (globals.size > 0) {
          ast.program.program.body.unshift(...[...globals.values()].filter(Boolean).map(({
            code
          }) => _template().default.statement(code)()));
          isASTDirty = true;
        }
      }
    } // Collect dependencies


    if (code == null || canHaveDependencies(code)) {
      (0, _babylonWalk().ancestor)(ast.program, _dependencies().default, {
        asset,
        ast,
        options,
        logger
      });
    } // If there's a hashbang, remove it and store it on the asset meta.
    // During packaging, if this is the entry asset, it will be prepended to the
    // packaged output.


    if (ast.program.program.interpreter != null) {
      asset.meta.interpreter = ast.program.program.interpreter.value;
      delete ast.program.program.interpreter;
      isASTDirty = true;
    }

    if (asset.env.shouldScopeHoist) {
      (0, _scopeHoisting().hoist)(asset, ast);
    } else if (asset.meta.isES6Module) {
      // Convert ES6 modules to CommonJS
      (0, _modules().esm2cjs)(ast.program, asset);
      isASTDirty = true;
    }

    if (isASTDirty) {
      asset.setAST(ast);
    }

    return [asset];
  },

  generate({
    asset,
    ast,
    options
  }) {
    return (0, _babelAstUtils().generate)({
      asset,
      ast,
      options
    });
  }

});

exports.default = _default;